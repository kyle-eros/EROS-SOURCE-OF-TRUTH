[
  {
    "id": "caption_features_vNext",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-13 10:35:56",
    "modified": "2025-09-13 10:35:56",
    "query": "WITH\nmessage_caption_facts AS (\n  SELECT\n    mf.caption_hash,\n    mf.username_std,\n    CONCAT(mf.username_std, '__', COALESCE(pta.page_type, 'main')) AS username_page,\n    mf.sending_ts,\n    mf.price_usd,\n    mf.earnings_usd,\n    mf.sent,\n    mf.viewed,\n    mf.purchased,\n    cd.caption_id,\n    cd.caption_text,\n    COALESCE(cd.caption_type, 'general') AS category,\n    COALESCE(cd.explicitness, 'medium') AS explicitness\n  FROM layer_04_semantic.message_facts mf\n  LEFT JOIN layer_04_semantic.v_page_type_authority pta\n    ON mf.username_std = pta.username_std\n  LEFT JOIN layer_04_semantic.v_caption_dim cd\n    ON mf.caption_hash = cd.caption_hash\n    AND mf.username_std = cd.username_std\n  WHERE mf.sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 90 DAY)\n    AND mf.sent > 0\n    AND mf.caption_hash IS NOT NULL\n),\nglobal_priors AS (\n  SELECT\n    AVG(SAFE_DIVIDE(purchased, NULLIF(sent, 0))) AS global_conversion_rate,\n    AVG(SAFE_DIVIDE(earnings_usd, NULLIF(sent, 0))) AS global_rps,\n    AVG(SAFE_DIVIDE(viewed, NULLIF(sent, 0))) AS global_open_rate,\n    STDDEV(SAFE_DIVIDE(purchased, NULLIF(sent, 0))) AS global_conversion_std,\n    COUNT(DISTINCT caption_hash) AS total_captions,\n    COUNT(*) AS total_observations\n  FROM message_caption_facts\n),\npage_priors AS (\n  SELECT\n    username_page,\n    AVG(SAFE_DIVIDE(purchased, NULLIF(sent, 0))) AS page_conversion_rate,\n    AVG(SAFE_DIVIDE(earnings_usd, NULLIF(sent, 0))) AS page_rps,\n    AVG(SAFE_DIVIDE(viewed, NULLIF(sent, 0))) AS page_open_rate,\n    COUNT(*) AS page_observations\n  FROM message_caption_facts\n  GROUP BY username_page\n),\ncaption_performance AS (\n  SELECT\n    mcf.caption_hash,\n    mcf.caption_id,\n    mcf.caption_text,\n    mcf.category,\n    mcf.explicitness,\n    mcf.username_page,\n    SUM(mcf.sent) AS total_sent,\n    SUM(mcf.viewed) AS total_viewed,\n    SUM(mcf.purchased) AS total_purchased,\n    SUM(mcf.earnings_usd) AS total_revenue,\n    SUM(mcf.sent * POW(0.95, DATE_DIFF(CURRENT_DATE(), DATE(mcf.sending_ts), DAY))) AS weighted_sent,\n    SUM(mcf.viewed * POW(0.95, DATE_DIFF(CURRENT_DATE(), DATE(mcf.sending_ts), DAY))) AS weighted_viewed,\n    SUM(mcf.purchased * POW(0.95, DATE_DIFF(CURRENT_DATE(), DATE(mcf.sending_ts), DAY))) AS weighted_purchased,\n    SUM(mcf.earnings_usd * POW(0.95, DATE_DIFF(CURRENT_DATE(), DATE(mcf.sending_ts), DAY))) AS weighted_revenue,\n    MAX(mcf.sending_ts) AS last_used_ts,\n    COUNT(DISTINCT DATE(mcf.sending_ts)) AS days_used,\n    COUNT(DISTINCT mcf.price_usd) AS price_points_tested,\n    STDDEV(SAFE_DIVIDE(mcf.purchased, NULLIF(mcf.sent, 0))) AS conversion_variance,\n    STDDEV(SAFE_DIVIDE(mcf.earnings_usd, NULLIF(mcf.sent, 0))) AS rps_variance\n  FROM message_caption_facts mcf\n  WHERE mcf.caption_id IS NOT NULL\n  GROUP BY\n    mcf.caption_hash,\n    mcf.caption_id,\n    mcf.caption_text,\n    mcf.category,\n    mcf.explicitness,\n    mcf.username_page\n),\nsmoothed_metrics AS (\n  SELECT\n    cp.*,\n    SAFE_DIVIDE(\n      cp.weighted_purchased + gp.global_conversion_rate * LEAST(30, GREATEST(5, 100 - cp.weighted_sent)),\n      cp.weighted_sent + LEAST(30, GREATEST(5, 100 - cp.weighted_sent))\n    ) AS smoothed_conversion_rate,\n    SAFE_DIVIDE(\n      cp.weighted_revenue + gp.global_rps * LEAST(30, GREATEST(5, 100 - cp.weighted_sent)),\n      cp.weighted_sent + LEAST(30, GREATEST(5, 100 - cp.weighted_sent))\n    ) AS smoothed_rps,\n    SAFE_DIVIDE(\n      cp.weighted_viewed + gp.global_open_rate * LEAST(30, GREATEST(5, 100 - cp.weighted_sent)),\n      cp.weighted_sent + LEAST(30, GREATEST(5, 100 - cp.weighted_sent))\n    ) AS smoothed_open_rate,\n    SAFE_DIVIDE(cp.total_purchased, NULLIF(cp.total_sent, 0)) AS raw_conversion_rate,\n    SAFE_DIVIDE(cp.total_revenue, NULLIF(cp.total_sent, 0)) AS raw_rps,\n    SAFE_DIVIDE(cp.total_viewed, NULLIF(cp.total_sent, 0)) AS raw_open_rate,\n    LEAST(1.0,\n      SQRT(2 * LN(gp.total_observations) / GREATEST(1, cp.weighted_sent)) +\n      COALESCE(cp.conversion_variance, 0.1) * 2\n    ) AS exploration_bonus\n  FROM caption_performance cp\n  CROSS JOIN global_priors gp\n  LEFT JOIN page_priors pp USING (username_page)\n),\nnovelty_scores AS (\n  SELECT\n    sm.*,\n    DATE_DIFF(CURRENT_DATE(), DATE(sm.last_used_ts), DAY) AS days_since_used,\n    CASE\n      WHEN DATE_DIFF(CURRENT_DATE(), DATE(sm.last_used_ts), DAY) < 7 THEN\n        EXP(-0.5 * (7 - DATE_DIFF(CURRENT_DATE(), DATE(sm.last_used_ts), DAY)))\n      ELSE 1.0\n    END AS novelty_score,\n    CASE\n      WHEN sm.days_used > 20 THEN 0.7\n      WHEN sm.days_used > 10 THEN 0.85\n      ELSE 1.0\n    END AS usage_intensity_factor\n  FROM smoothed_metrics sm\n),\nnormalized_features AS (\n  SELECT\n    ns.*,\n    SAFE_DIVIDE(\n      ns.smoothed_conversion_rate - AVG(ns.smoothed_conversion_rate) OVER (PARTITION BY ns.username_page),\n      NULLIF(STDDEV(ns.smoothed_conversion_rate) OVER (PARTITION BY ns.username_page), 0)\n    ) AS conversion_z_score,\n    SAFE_DIVIDE(\n      ns.smoothed_rps - AVG(ns.smoothed_rps) OVER (PARTITION BY ns.username_page),\n      NULLIF(STDDEV(ns.smoothed_rps) OVER (PARTITION BY ns.username_page), 0)\n    ) AS rps_z_score,\n    SAFE_DIVIDE(\n      ns.smoothed_open_rate - AVG(ns.smoothed_open_rate) OVER (PARTITION BY ns.username_page),\n      NULLIF(STDDEV(ns.smoothed_open_rate) OVER (PARTITION BY ns.username_page), 0)\n    ) AS open_z_score,\n    PERCENT_RANK() OVER (PARTITION BY ns.username_page ORDER BY ns.smoothed_conversion_rate) AS conversion_percentile,\n    PERCENT_RANK() OVER (PARTITION BY ns.username_page ORDER BY ns.smoothed_rps) AS rps_percentile,\n    PERCENT_RANK() OVER (PARTITION BY ns.username_page ORDER BY ns.smoothed_open_rate) AS open_percentile\n  FROM novelty_scores ns\n)\nSELECT\n  nf.caption_id,\n  nf.caption_text,\n  nf.caption_hash,\n  nf.username_page,\n  nf.category,\n  nf.explicitness,\n  ROUND(nf.smoothed_conversion_rate, 4) AS conversion_rate,\n  ROUND(nf.smoothed_rps, 2) AS rps,\n  ROUND(nf.rps_z_score, 3) AS rps_z_score,\n  ROUND(nf.open_percentile, 3) AS open_percentile,\n  ROUND(nf.novelty_score, 3) AS novelty_score,\n  ROUND(nf.usage_intensity_factor, 3) AS usage_intensity_factor,\n  ROUND(nf.exploration_bonus, 3) AS exploration_bonus,\n  nf.total_sent,\n  nf.days_used,\n  nf.days_since_used,\n  nf.last_used_ts,\n  nf.price_points_tested,\n  ROUND(nf.conversion_variance, 4) AS conversion_variance,\n  ROUND(nf.rps_variance, 2) AS rps_variance,\n  CASE WHEN nf.total_sent < 10 THEN TRUE ELSE FALSE END AS is_cold_start,\n  CASE WHEN nf.days_since_used > 28 THEN TRUE ELSE FALSE END AS is_stale,\n  CURRENT_TIMESTAMP() AS computation_ts\nFROM normalized_features nf\nWHERE nf.caption_id IS NOT NULL\n  AND nf.caption_text IS NOT NULL",
    "schema": [
      {
        "name": "caption_id",
        "type": "STRING"
      },
      {
        "name": "caption_text",
        "type": "STRING"
      },
      {
        "name": "caption_hash",
        "type": "STRING"
      },
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "category",
        "type": "STRING"
      },
      {
        "name": "explicitness",
        "type": "STRING"
      },
      {
        "name": "conversion_rate",
        "type": "FLOAT"
      },
      {
        "name": "rps",
        "type": "FLOAT"
      },
      {
        "name": "rps_z_score",
        "type": "FLOAT"
      },
      {
        "name": "open_percentile",
        "type": "FLOAT"
      },
      {
        "name": "novelty_score",
        "type": "FLOAT"
      },
      {
        "name": "usage_intensity_factor",
        "type": "FLOAT"
      },
      {
        "name": "exploration_bonus",
        "type": "FLOAT"
      },
      {
        "name": "total_sent",
        "type": "INTEGER"
      },
      {
        "name": "days_used",
        "type": "INTEGER"
      },
      {
        "name": "days_since_used",
        "type": "INTEGER"
      },
      {
        "name": "last_used_ts",
        "type": "TIMESTAMP"
      },
      {
        "name": "price_points_tested",
        "type": "INTEGER"
      },
      {
        "name": "conversion_variance",
        "type": "FLOAT"
      },
      {
        "name": "rps_variance",
        "type": "FLOAT"
      },
      {
        "name": "is_cold_start",
        "type": "BOOLEAN"
      },
      {
        "name": "is_stale",
        "type": "BOOLEAN"
      },
      {
        "name": "computation_ts",
        "type": "TIMESTAMP"
      }
    ]
  },
  {
    "id": "caption_ranker_vNext",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-11 07:39:55",
    "modified": "2025-09-11 07:39:55",
    "query": "WITH \n-- FIXED: ML weights with username_std and proper latest selection\nml_weights AS (\n  SELECT\n    ps.username_std,\n    ps.page_state,\n    w.w_rps, w.w_open, w.w_buy, w.w_dowhod, w.w_price, w.w_novelty, w.w_momentum,\n    w.ucb_c, w.epsilon\n  FROM `of-scheduler-proj.core.page_state` ps\n  JOIN (\n    SELECT * EXCEPT(rn)\n    FROM (\n      SELECT *,\n             ROW_NUMBER() OVER (PARTITION BY page_state ORDER BY updated_at DESC) AS rn\n      FROM `of-scheduler-proj.ops.ml_ranking_weights_v1`\n    )\n    WHERE rn = 1\n  ) w USING (page_state)\n),\n\n-- Get exploration config with proper latest selection\nexplore_config AS (\n  SELECT * EXCEPT(rn)\n  FROM (\n    SELECT *,\n           ROW_NUMBER() OVER (PARTITION BY config_key ORDER BY updated_at DESC) AS rn\n    FROM `of-scheduler-proj.ops.explore_exploit_config_v1`\n  )\n  WHERE config_key = 'default' AND rn = 1\n),\n\n-- FIXED: Get cooldown config from settings\ncooldown_config AS (\n  SELECT \n    CAST(MAX(CASE WHEN setting_key = 'min_cooldown_hours' THEN setting_value END) AS INT64) AS min_cooldown_hours,\n    21 * 24 AS max_cooldown_hours,  -- 21 days from max_cooldown_days setting\n    3 AS max_weekly_uses  -- Standard max weekly uses\n  FROM `of-scheduler-proj.core.cooldown_settings_v1`\n  WHERE setting_key IN ('min_cooldown_hours', 'max_cooldown_days')\n),\n\n-- Get scheduled slots for next 7 days\nscheduled_slots AS (\n  SELECT\n    username_page,\n    username_std,\n    page_type,\n    date_local AS slot_dt_local,\n    hod_local,\n    slot_rank,\n    tracking_hash,\n    MOD(EXTRACT(DAYOFWEEK FROM date_local) + 5, 7) AS dow_local\n  FROM `of-scheduler-proj.core.v_weekly_template_7d_pages_final`\n  WHERE date_local BETWEEN CURRENT_DATE() AND DATE_ADD(CURRENT_DATE(), INTERVAL 7 DAY)\n),\n\n-- Get DOWÃ—HOD performance patterns\ndow_hod_patterns AS (\n  SELECT\n    username_std,\n    dow_local,\n    hod_local,\n    score AS dow_hod_score,\n    PERCENT_RANK() OVER (PARTITION BY username_std ORDER BY score) AS dow_hod_percentile\n  FROM `of-scheduler-proj.mart.v_mm_dow_hod_180d_local_v2`\n),\n\n-- FIXED: Price elasticity - one row per page with optimal band\nprice_elasticity AS (\n  SELECT \n    username_page,\n    ANY_VALUE(optimal_band) AS optimal_band,\n    MAX_BY(band_rps, band_rps) AS optimal_band_rps\n  FROM (\n    SELECT \n      username_page,\n      price_band,\n      AVG(SAFE_DIVIDE(earnings_usd, NULLIF(sent, 0))) AS band_rps,\n      FIRST_VALUE(price_band) OVER (\n        PARTITION BY username_page \n        ORDER BY AVG(SAFE_DIVIDE(earnings_usd, NULLIF(sent, 0))) DESC\n      ) AS optimal_band\n    FROM (\n      SELECT \n        CONCAT(mf.username_std, '__', COALESCE(pta.page_type, 'main')) AS username_page,\n        mf.earnings_usd,\n        mf.sent,\n        mf.price_usd,\n        CASE \n          WHEN mf.price_usd < 15 THEN 'low'\n          WHEN mf.price_usd < 30 THEN 'mid'\n          WHEN mf.price_usd < 45 THEN 'high'\n          ELSE 'premium'\n        END AS price_band\n      FROM `of-scheduler-proj.core.message_facts` mf\n      LEFT JOIN `of-scheduler-proj.core.page_type_authority` pta\n        ON mf.username_std = pta.username_std\n      WHERE mf.sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 90 DAY)\n        AND mf.sent > 0\n    )\n    GROUP BY username_page, price_band\n  )\n  GROUP BY username_page\n),\n\n-- FIXED: Cooldown check with TIMESTAMP_DIFF\ncooldown_check AS (\n  SELECT\n    cd.caption_id,\n    CONCAT(mf.username_std, '__', COALESCE(pta.page_type, 'main')) AS username_page,\n    MAX(mf.sending_ts) AS last_sent_ts,\n    COUNTIF(mf.sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY)) AS recent_uses_7d,\n    COUNT(DISTINCT DATE(mf.sending_ts)) AS unique_days_7d\n  FROM `of-scheduler-proj.core.message_facts` mf\n  LEFT JOIN `of-scheduler-proj.core.page_type_authority` pta\n    ON mf.username_std = pta.username_std\n  LEFT JOIN `of-scheduler-proj.core.caption_dim` cd\n    ON mf.caption_hash = cd.caption_hash\n    AND mf.username_std = cd.username_std\n  WHERE mf.caption_hash IS NOT NULL\n    AND cd.caption_id IS NOT NULL\n  GROUP BY cd.caption_id, username_page\n),\n\n-- Calculate momentum scores\nmomentum_scores AS (\n  SELECT\n    CONCAT(mf.username_std, '__', COALESCE(pta.page_type, 'main')) AS username_page,\n    SAFE_DIVIDE(\n      SUM(CASE WHEN mf.sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY) \n               THEN mf.earnings_usd END),\n      NULLIF(SUM(CASE WHEN mf.sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY) \n                      THEN mf.sent END), 0)\n    ) AS rps_7d,\n    SAFE_DIVIDE(\n      SUM(CASE WHEN mf.sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 30 DAY) \n               THEN mf.earnings_usd END),\n      NULLIF(SUM(CASE WHEN mf.sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 30 DAY) \n                      THEN mf.sent END), 0)\n    ) AS rps_30d,\n    SAFE_DIVIDE(\n      SAFE_DIVIDE(\n        SUM(CASE WHEN mf.sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY) \n                 THEN mf.earnings_usd END),\n        NULLIF(SUM(CASE WHEN mf.sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY) \n                        THEN mf.sent END), 0)\n      ),\n      NULLIF(SAFE_DIVIDE(\n        SUM(CASE WHEN mf.sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 30 DAY) \n                 THEN mf.earnings_usd END),\n        NULLIF(SUM(CASE WHEN mf.sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 30 DAY) \n                        THEN mf.sent END), 0)\n      ), 0)\n    ) AS momentum_ratio\n  FROM `of-scheduler-proj.core.message_facts` mf\n  LEFT JOIN `of-scheduler-proj.core.page_type_authority` pta\n    ON mf.username_std = pta.username_std\n  WHERE mf.sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 30 DAY)\n    AND mf.sent > 0\n  GROUP BY username_page\n),\n\n-- FIXED: Combine features with proper JOINs (not CROSS JOIN)\nscored_captions AS (\n  SELECT\n    ss.username_page,\n    ss.username_std,\n    ss.page_type,\n    ss.slot_dt_local,\n    ss.hod_local,\n    ss.dow_local,\n    ss.slot_rank,\n    ss.tracking_hash,\n    cf.caption_id,\n    cf.caption_text,\n    cf.caption_hash,\n    cf.category,\n    cf.explicitness,\n    \n    -- Raw features\n    cf.conversion_rate,\n    cf.rps,\n    cf.open_rate,\n    COALESCE(dhp.dow_hod_score, 0) AS dow_hod_score,\n    COALESCE(dhp.dow_hod_percentile, 0.5) AS dow_hod_percentile,\n    cf.novelty_score,\n    COALESCE(ms.momentum_ratio, 1.0) AS momentum_score,\n    \n    -- Normalized features\n    cf.rps_z_score,\n    cf.conversion_z_score,\n    cf.open_z_score,\n    \n    -- ML weights\n    mw.w_rps,\n    mw.w_open,\n    mw.w_buy,\n    mw.w_dowhod,\n    mw.w_price,\n    mw.w_novelty,\n    mw.w_momentum,\n    mw.ucb_c,\n    mw.epsilon,\n    \n    -- Exploration bonus\n    cf.exploration_bonus,\n    ec.max_explorer_share,\n    \n    -- FIXED: Deterministic epsilon flag using hash\n    (ABS(FARM_FINGERPRINT(CONCAT(\n      cf.caption_id,\n      FORMAT_DATE('%Y%m%d', ss.slot_dt_local),\n      CAST(ss.hod_local AS STRING)\n    ))) / 9.22e18) < mw.epsilon AS epsilon_flag,\n    \n    -- Calculate final score\n    (\n      mw.w_rps * COALESCE(cf.rps_z_score, 0) +\n      mw.w_open * COALESCE(cf.open_z_score, 0) +\n      mw.w_buy * COALESCE(cf.conversion_z_score, 0) +\n      mw.w_dowhod * COALESCE((dhp.dow_hod_percentile - 0.5) * 2, 0) +\n      mw.w_price * CASE \n        WHEN pe.optimal_band = 'mid' AND cf.rps > pe.optimal_band_rps THEN 0.2\n        WHEN pe.optimal_band = 'high' AND cf.rps > pe.optimal_band_rps THEN 0.1\n        ELSE 0\n      END +\n      mw.w_novelty * cf.novelty_score +\n      mw.w_momentum * LEAST(1.5, GREATEST(0.5, COALESCE(ms.momentum_ratio, 1.0))) +\n      -- UCB exploration bonus (deterministic)\n      CASE \n        WHEN cf.is_cold_start THEN mw.ucb_c * cf.exploration_bonus\n        WHEN (ABS(FARM_FINGERPRINT(CONCAT(\n          cf.caption_id,\n          FORMAT_DATE('%Y%m%d', ss.slot_dt_local),\n          CAST(ss.hod_local AS STRING)\n        ))) / 9.22e18) < mw.epsilon THEN 2.0\n        ELSE 0\n      END\n    ) AS score_final,\n    \n    -- FIXED: Compliance flags with config-driven thresholds\n    CASE \n      WHEN cc.recent_uses_7d >= (SELECT max_weekly_uses FROM cooldown_config) THEN FALSE\n      WHEN cc.unique_days_7d >= 3 THEN FALSE\n      WHEN cc.last_sent_ts IS NOT NULL \n        AND TIMESTAMP_DIFF(CURRENT_TIMESTAMP(), cc.last_sent_ts, HOUR) < \n            (SELECT min_cooldown_hours FROM cooldown_config) THEN FALSE\n      ELSE TRUE\n    END AS cooldown_ok,\n    \n    TRUE AS quota_ok,  -- Would join with quota table\n    \n    CASE \n      WHEN cc.recent_uses_7d > 0 THEN FALSE\n      ELSE TRUE\n    END AS dedupe_ok,\n    \n    CASE \n      WHEN cf.is_cold_start THEN TRUE\n      WHEN (ABS(FARM_FINGERPRINT(CONCAT(\n        cf.caption_id,\n        FORMAT_DATE('%Y%m%d', ss.slot_dt_local),\n        CAST(ss.hod_local AS STRING)\n      ))) / 9.22e18) < mw.epsilon THEN TRUE\n      ELSE FALSE\n    END AS is_explorer,\n    \n    -- Metadata\n    cf.total_sent,\n    cf.days_since_used,\n    cf.is_cold_start,\n    cf.is_stale,\n    cc.recent_uses_7d,\n    \n    -- Reason codes\n    CASE\n      WHEN cf.is_cold_start THEN 'cold_start_exploration'\n      WHEN (ABS(FARM_FINGERPRINT(CONCAT(\n        cf.caption_id,\n        FORMAT_DATE('%Y%m%d', ss.slot_dt_local),\n        CAST(ss.hod_local AS STRING)\n      ))) / 9.22e18) < mw.epsilon THEN 'epsilon_exploration'\n      WHEN cf.rps_percentile > 0.8 THEN 'high_performer'\n      WHEN dhp.dow_hod_percentile > 0.7 THEN 'optimal_timing'\n      WHEN cf.novelty_score > 0.9 THEN 'fresh_content'\n      ELSE 'balanced_selection'\n    END AS selection_reason\n    \n  FROM scheduled_slots ss\n  -- FIXED: Proper JOIN instead of CROSS JOIN\n  INNER JOIN `of-scheduler-proj.mart.caption_features_vNext` cf\n    ON cf.username_page = ss.username_page\n  LEFT JOIN ml_weights mw \n    ON ss.username_std = mw.username_std\n  LEFT JOIN dow_hod_patterns dhp \n    ON ss.username_std = dhp.username_std \n    AND ss.dow_local = dhp.dow_local \n    AND ss.hod_local = dhp.hod_local\n  LEFT JOIN price_elasticity pe \n    ON ss.username_page = pe.username_page\n  LEFT JOIN cooldown_check cc \n    ON cf.caption_id = cc.caption_id \n    AND ss.username_page = cc.username_page\n  LEFT JOIN momentum_scores ms \n    ON ss.username_page = ms.username_page\n  CROSS JOIN explore_config ec\n  CROSS JOIN cooldown_config\n),\n\n-- Rank captions per slot\nranked_captions AS (\n  SELECT\n    *,\n    ROW_NUMBER() OVER (\n      PARTITION BY username_page, slot_dt_local, hod_local\n      ORDER BY \n        CASE WHEN cooldown_ok AND quota_ok AND dedupe_ok THEN 0 ELSE 1 END,\n        score_final DESC,\n        days_since_used DESC\n    ) AS rank_in_slot,\n    \n    COUNT(DISTINCT category) OVER (\n      PARTITION BY username_page, slot_dt_local, hod_local\n    ) AS category_diversity,\n    \n    -- FIXED: Normalize score per slot (not per page)\n    100 * (score_final - MIN(score_final) OVER (PARTITION BY username_page, slot_dt_local, hod_local)) / \n    NULLIF(\n      MAX(score_final) OVER (PARTITION BY username_page, slot_dt_local, hod_local) - \n      MIN(score_final) OVER (PARTITION BY username_page, slot_dt_local, hod_local), \n      0\n    ) AS score_normalized\n    \n  FROM scored_captions\n  WHERE caption_id IS NOT NULL\n    AND caption_text IS NOT NULL\n)\n\n-- Final output\nSELECT\n  username_page,\n  username_std,\n  page_type,\n  slot_dt_local,\n  hod_local,\n  dow_local,\n  slot_rank,\n  tracking_hash,\n  caption_id,\n  caption_text,\n  caption_hash,\n  category,\n  explicitness,\n  \n  ROUND(score_final, 3) AS score_final,\n  ROUND(score_normalized, 1) AS score_normalized,\n  rank_in_slot,\n  \n  ROUND(conversion_rate, 4) AS conversion_rate,\n  ROUND(rps, 2) AS rps,\n  ROUND(open_rate, 4) AS open_rate,\n  \n  ROUND(dow_hod_score, 2) AS dow_hod_score,\n  ROUND(dow_hod_percentile, 3) AS dow_hod_percentile,\n  \n  ROUND(novelty_score, 3) AS novelty_score,\n  ROUND(momentum_score, 3) AS momentum_score,\n  \n  cooldown_ok,\n  quota_ok,\n  dedupe_ok,\n  is_explorer,\n  \n  total_sent,\n  days_since_used,\n  recent_uses_7d,\n  is_cold_start,\n  is_stale,\n  selection_reason,\n  category_diversity,\n  \n  CURRENT_TIMESTAMP() AS ranked_at,\n  'v1.0.1-patched' AS model_version\n  \nFROM ranked_captions\nWHERE rank_in_slot <= 20\nQUALIFY ROW_NUMBER() OVER (\n  PARTITION BY username_page, slot_dt_local, hod_local, caption_id\n  ORDER BY rank_in_slot\n) = 1",
    "schema": [
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "page_type",
        "type": "STRING"
      },
      {
        "name": "slot_dt_local",
        "type": "DATE"
      },
      {
        "name": "hod_local",
        "type": "INTEGER"
      },
      {
        "name": "dow_local",
        "type": "INTEGER"
      },
      {
        "name": "slot_rank",
        "type": "INTEGER"
      },
      {
        "name": "tracking_hash",
        "type": "STRING"
      },
      {
        "name": "caption_id",
        "type": "STRING"
      },
      {
        "name": "caption_text",
        "type": "STRING"
      },
      {
        "name": "caption_hash",
        "type": "STRING"
      },
      {
        "name": "category",
        "type": "STRING"
      },
      {
        "name": "explicitness",
        "type": "STRING"
      },
      {
        "name": "score_final",
        "type": "FLOAT"
      },
      {
        "name": "score_normalized",
        "type": "FLOAT"
      },
      {
        "name": "rank_in_slot",
        "type": "INTEGER"
      },
      {
        "name": "conversion_rate",
        "type": "FLOAT"
      },
      {
        "name": "rps",
        "type": "FLOAT"
      },
      {
        "name": "open_rate",
        "type": "FLOAT"
      },
      {
        "name": "dow_hod_score",
        "type": "FLOAT"
      },
      {
        "name": "dow_hod_percentile",
        "type": "FLOAT"
      },
      {
        "name": "novelty_score",
        "type": "FLOAT"
      },
      {
        "name": "momentum_score",
        "type": "NUMERIC"
      },
      {
        "name": "cooldown_ok",
        "type": "BOOLEAN"
      },
      {
        "name": "quota_ok",
        "type": "BOOLEAN"
      },
      {
        "name": "dedupe_ok",
        "type": "BOOLEAN"
      },
      {
        "name": "is_explorer",
        "type": "BOOLEAN"
      },
      {
        "name": "total_sent",
        "type": "INTEGER"
      },
      {
        "name": "days_since_used",
        "type": "INTEGER"
      },
      {
        "name": "recent_uses_7d",
        "type": "INTEGER"
      },
      {
        "name": "is_cold_start",
        "type": "BOOLEAN"
      },
      {
        "name": "is_stale",
        "type": "BOOLEAN"
      },
      {
        "name": "selection_reason",
        "type": "STRING"
      },
      {
        "name": "category_diversity",
        "type": "INTEGER"
      },
      {
        "name": "ranked_at",
        "type": "TIMESTAMP"
      },
      {
        "name": "model_version",
        "type": "STRING"
      }
    ]
  },
  {
    "id": "sheet_caption_top10_today",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-06 05:39:06",
    "modified": "2025-09-06 05:39:06",
    "query": "SELECT\n  username_page, date_local, hod_local,\n  caption_id, caption_text, theme_tags, confidence_score, rnk\nFROM `of-scheduler-proj.mart.caption_scores_7d`\nWHERE date_local = CURRENT_DATE()\n  AND rnk <= 10\nORDER BY username_page, hod_local, rnk",
    "schema": [
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "date_local",
        "type": "DATE"
      },
      {
        "name": "hod_local",
        "type": "INTEGER"
      },
      {
        "name": "caption_id",
        "type": "STRING"
      },
      {
        "name": "caption_text",
        "type": "STRING"
      },
      {
        "name": "theme_tags",
        "type": "STRING"
      },
      {
        "name": "confidence_score",
        "type": "FLOAT"
      },
      {
        "name": "rnk",
        "type": "INTEGER"
      }
    ]
  },
  {
    "id": "sheet_captions_next24_v3",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-06 21:31:18",
    "modified": "2025-09-06 21:31:18",
    "query": "SELECT\n  username_page,\n  FORMAT_DATETIME('%a %b %d, %I:%M %p', slot_dt_local) AS slot_local_human,\n  caption_id,\n  ROUND(p_buy_eb,6)     AS buy_rate_eb,\n  ROUND(rps_eb_price,5) AS rps_eb,\n  ROUND(se_bonus,5)     AS ucb_bonus,\n  ROUND(style_score,4)  AS style,\n  is_cooldown_ok,\n  rn AS caption_rank\nFROM `of-scheduler-proj.mart.caption_rank_next24_v3_tbl`\nWHERE rn <= 3\nORDER BY username_page, slot_dt_local, caption_rank",
    "schema": [
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "slot_local_human",
        "type": "STRING"
      },
      {
        "name": "caption_id",
        "type": "STRING"
      },
      {
        "name": "buy_rate_eb",
        "type": "FLOAT"
      },
      {
        "name": "rps_eb",
        "type": "FLOAT"
      },
      {
        "name": "ucb_bonus",
        "type": "FLOAT"
      },
      {
        "name": "style",
        "type": "FLOAT"
      },
      {
        "name": "is_cooldown_ok",
        "type": "BOOLEAN"
      },
      {
        "name": "caption_rank",
        "type": "INTEGER"
      }
    ]
  },
  {
    "id": "sheet_slots_next24_v3",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-06 21:31:10",
    "modified": "2025-09-06 21:31:10",
    "query": "SELECT\n  r.username_page,\n  FORMAT_DATETIME('%a %b %d, %I:%M %p', r.slot_dt_local) AS slot_local_human,\n  r.dow, r.hod,\n  r.reco_dm_type,\n  r.reco_price_usd,\n  ROUND(r.best_ppv_buy_rate, 5) AS est_buy_rate,\n  ROUND(r.rps_lcb, 5)          AS est_rps_lcb,\n  ROUND(r.slot_score_base, 5)  AS slot_score\nFROM `of-scheduler-proj.mart.v_slot_recommendations_next24_v3` r\nORDER BY r.username_page, r.slot_dt_local",
    "schema": [
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "slot_local_human",
        "type": "STRING"
      },
      {
        "name": "dow",
        "type": "INTEGER"
      },
      {
        "name": "hod",
        "type": "INTEGER"
      },
      {
        "name": "reco_dm_type",
        "type": "STRING"
      },
      {
        "name": "reco_price_usd",
        "type": "NUMERIC"
      },
      {
        "name": "est_buy_rate",
        "type": "FLOAT"
      },
      {
        "name": "est_rps_lcb",
        "type": "FLOAT"
      },
      {
        "name": "slot_score",
        "type": "FLOAT"
      }
    ]
  },
  {
    "id": "v_caption_candidate_pool_v3",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-13 12:49:23",
    "modified": "2025-09-13 12:49:23",
    "query": "WITH cd AS (\n  SELECT CAST(setting_val AS INT64) AS cooldown_days\n  FROM `of-scheduler-proj.ops_config.settings_modeling`\n  WHERE setting_key=\"caption_cooldown_days\"\n)\nSELECT\n  f.username_page, f.caption_id, f.caption_hash, f.caption_text,\n  f.len_bin, f.emoji_bin, f.has_cta, f.has_urgency, f.ends_with_question,\n  lu.last_used_ts,\n  CASE\n    WHEN lu.last_used_ts IS NULL THEN TRUE\n    WHEN lu.last_used_ts < TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL (SELECT cooldown_days FROM cd LIMIT 1) DAY) THEN TRUE\n    ELSE FALSE\n  END AS is_cooldown_ok\nFROM `of-scheduler-proj.layer_05_ml.v_caption_safe_candidates` f\nLEFT JOIN `of-scheduler-proj.layer_05_ml.v_caption_last_used` lu\n  ON f.creator_username = lu.username_std AND f.caption_hash = lu.caption_hash",
    "schema": [
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "caption_id",
        "type": "STRING"
      },
      {
        "name": "caption_hash",
        "type": "STRING"
      },
      {
        "name": "caption_text",
        "type": "STRING"
      },
      {
        "name": "len_bin",
        "type": "STRING"
      },
      {
        "name": "emoji_bin",
        "type": "STRING"
      },
      {
        "name": "has_cta",
        "type": "BOOLEAN"
      },
      {
        "name": "has_urgency",
        "type": "BOOLEAN"
      },
      {
        "name": "ends_with_question",
        "type": "BOOLEAN"
      },
      {
        "name": "last_used_ts",
        "type": "TIMESTAMP"
      },
      {
        "name": "is_cooldown_ok",
        "type": "BOOLEAN"
      }
    ]
  },
  {
    "id": "v_caption_decayed_stats_60d_v3",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-06 19:27:10",
    "modified": "2025-09-06 19:27:10",
    "query": "WITH cfg AS (SELECT 14.0 AS hl_days),\nf AS (\n  SELECT username_page, caption_hash, sending_ts_utc, purchased, sent, earnings\n  FROM `of-scheduler-proj.mart.fn_dm_send_facts`(60)\n  WHERE dm_type='ppv'\n)\nSELECT\n  username_page,\n  caption_hash,\n  SUM(purchased * `of-scheduler-proj.util.halflife_weight`(sending_ts_utc, (SELECT hl_days FROM cfg))) AS decayed_purchases,\n  SUM(sent      * `of-scheduler-proj.util.halflife_weight`(sending_ts_utc, (SELECT hl_days FROM cfg))) AS decayed_sent,\n  SUM(earnings  * `of-scheduler-proj.util.halflife_weight`(sending_ts_utc, (SELECT hl_days FROM cfg))) AS decayed_revenue,\n  SAFE_DIVIDE(SUM(earnings), NULLIF(SUM(sent),0)) AS naive_rps_all\nFROM f\nGROUP BY 1,2",
    "schema": [
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "caption_hash",
        "type": "STRING"
      },
      {
        "name": "decayed_purchases",
        "type": "FLOAT"
      },
      {
        "name": "decayed_sent",
        "type": "FLOAT"
      },
      {
        "name": "decayed_revenue",
        "type": "FLOAT"
      },
      {
        "name": "naive_rps_all",
        "type": "NUMERIC"
      }
    ]
  },
  {
    "id": "v_caption_rank_next24_v3",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-06 21:05:25",
    "modified": "2025-09-06 21:05:25",
    "query": "WITH params AS (\n  SELECT\n    CAST(COALESCE(MAX(CASE WHEN setting_key='prior_nu_buy'        THEN setting_val END), '200') AS FLOAT64) AS nu_buy,\n    CAST(COALESCE(MAX(CASE WHEN setting_key='w_style_lift'        THEN setting_val END), '0.10') AS FLOAT64) AS w_style,\n    CAST(COALESCE(MAX(CASE WHEN setting_key='ucb_sigma_min'       THEN setting_val END), '0.15') AS FLOAT64) AS ucb_sigma_min,\n    CAST(COALESCE(MAX(CASE WHEN setting_key='ucb_sigma_max'       THEN setting_val END), '0.60') AS FLOAT64) AS ucb_sigma_max,\n    CAST(COALESCE(MAX(CASE WHEN setting_key='ucb_bonus_cap_mult'  THEN setting_val END), '2.0')  AS FLOAT64) AS ucb_cap_mult\n  FROM `of-scheduler-proj.core.settings_modeling`\n),\nslots AS (\n  SELECT username_page, slot_dt_local, dow, hod, reco_dm_type, reco_price_usd\n  FROM `of-scheduler-proj.mart.v_slot_recommendations_next24_v3`\n),\n-- candidate pool (force canonical order & types)\ncand0_typed AS (\n  SELECT\n    CAST(username_page AS STRING)         AS username_page,\n    CAST(caption_id   AS STRING)          AS caption_id,\n    CAST(caption_hash AS STRING)          AS caption_hash,\n    CAST(caption_text AS STRING)          AS caption_text,\n    CAST(len_bin      AS STRING)          AS len_bin,\n    CAST(emoji_bin    AS STRING)          AS emoji_bin,\n    CAST(has_cta      AS BOOL)            AS has_cta,\n    CAST(has_urgency  AS BOOL)            AS has_urgency,\n    CAST(ends_with_question AS BOOL)      AS ends_with_question,\n    CAST(last_used_ts AS TIMESTAMP)       AS last_used_ts,\n    CAST(is_cooldown_ok AS BOOL)          AS is_cooldown_ok\n  FROM `of-scheduler-proj.mart.v_caption_candidate_pool_v3`\n),\npages_in_play AS (SELECT DISTINCT username_page FROM slots),\npages_without_cand AS (\n  SELECT p.username_page\n  FROM pages_in_play p\n  LEFT JOIN (SELECT DISTINCT username_page FROM cand0_typed) c USING (username_page)\n  WHERE c.username_page IS NULL\n),\n-- one synthetic (prior-only) fallback per page\nfallback_cand_typed AS (\n  SELECT\n    CAST(username_page AS STRING)                                    AS username_page,\n    CAST('fallback_default' AS STRING)                                AS caption_id,\n    CAST(TO_HEX(SHA256(CONCAT(username_page,'|fallback_default'))) AS STRING) AS caption_hash,\n    CAST(NULL AS STRING)                                             AS caption_text,\n    CAST('short' AS STRING)                                          AS len_bin,\n    CAST('no_emoji' AS STRING)                                       AS emoji_bin,\n    CAST(FALSE AS BOOL)                                              AS has_cta,\n    CAST(FALSE AS BOOL)                                              AS has_urgency,\n    CAST(FALSE AS BOOL)                                              AS ends_with_question,\n    CAST(NULL  AS TIMESTAMP)                                         AS last_used_ts,\n    CAST(TRUE  AS BOOL)                                              AS is_cooldown_ok\n  FROM pages_without_cand\n),\ncand AS (\n  SELECT * FROM cand0_typed\n  UNION ALL\n  SELECT * FROM fallback_cand_typed\n),\nstyle AS (SELECT * FROM `of-scheduler-proj.mart.v_dm_style_lift_28d_v3`),\nstats AS (SELECT * FROM `of-scheduler-proj.mart.v_caption_decayed_stats_60d_v3`),\npri   AS (SELECT username_page, mu_buy_sent FROM `of-scheduler-proj.mart.v_page_priors_l90_v3`),\n-- recent volume for adaptive exploration\nslot_vol AS (\n  SELECT username_page, dow, hod, SUM(sent) AS sent_28d\n  FROM `of-scheduler-proj.mart.fn_dm_send_facts`(28)\n  GROUP BY 1,2,3\n),\npage_vol AS (\n  SELECT username_page, SUM(decayed_sent) AS decayed_sent_60d\n  FROM `of-scheduler-proj.mart.v_caption_decayed_stats_60d_v3`\n  GROUP BY 1\n),\nslot_cand AS (\n  SELECT\n    s.username_page, s.slot_dt_local, s.dow, s.hod, s.reco_dm_type,\n    GREATEST(s.reco_price_usd,0.0) AS price,\n    c.caption_id, c.caption_hash, c.caption_text,\n    c.len_bin, c.emoji_bin, c.has_cta, c.has_urgency, c.ends_with_question,\n    c.is_cooldown_ok,\n    SUM(CASE WHEN c.is_cooldown_ok THEN 1 ELSE 0 END)\n      OVER (PARTITION BY s.username_page, s.slot_dt_local) AS ok_cnt_in_slot,\n    COALESCE(TIMESTAMP_DIFF(CURRENT_TIMESTAMP(), c.last_used_ts, DAY), 999999) AS days_since_last_use\n  FROM slots s\n  JOIN cand  c USING (username_page)\n),\nstyled AS (\n  SELECT\n    b.*,\n    (SELECT w_style FROM params) * COALESCE(sl.lift_vs_slot_smooth_clamped, 0.0) AS style_score\n  FROM slot_cand b\n  LEFT JOIN style sl\n    ON sl.username_page=b.username_page AND sl.dow=b.dow AND sl.hod=b.hod\n   AND sl.len_bin=b.len_bin AND sl.emoji_bin=b.emoji_bin\n   AND sl.has_cta=b.has_cta AND sl.has_urgency=b.has_urgency\n   AND sl.ends_with_question=b.ends_with_question\n),\neb AS (\n  SELECT\n    t.*,\n    COALESCE(st.decayed_purchases, 0.0) AS x,\n    COALESCE(st.decayed_sent,      0.0) AS n,\n    COALESCE(pr.mu_buy_sent,0.08)  AS mu_page,\n    (SELECT nu_buy FROM params)    AS nu,\n    SAFE_DIVIDE(COALESCE(st.decayed_purchases,0.0) + (SELECT nu_buy FROM params) * COALESCE(pr.mu_buy_sent,0.08),\n                COALESCE(st.decayed_sent,0.0)      + (SELECT nu_buy FROM params)) AS p_buy_eb\n  FROM styled t\n  LEFT JOIN stats st USING (username_page, caption_hash)\n  LEFT JOIN pri   pr USING (username_page)\n),\nucb AS (\n  SELECT\n    e.*,\n    GREATEST(e.n + e.nu, 1.0) AS n_eff,\n    COALESCE(sv.sent_28d, 0.0)         AS sent_28d,\n    COALESCE(pv.decayed_sent_60d, 0.0) AS decayed_sent_60d,\n    (SELECT ucb_sigma_min FROM params) +\n    ((SELECT ucb_sigma_max FROM params) - (SELECT ucb_sigma_min FROM params)) *\n    ( 0.5 * (1.0 / (1.0 + LOG10(1.0 + COALESCE(sv.sent_28d,0.0))))\n    + 0.5 * (1.0 / (1.0 + LOG10(1.0 + COALESCE(pv.decayed_sent_60d,0.0)))) ) AS sigma_adapted,\n    CASE WHEN e.price > 0 THEN\n      (\n        ( (SELECT ucb_sigma_min FROM params) +\n          ((SELECT ucb_sigma_max FROM params) - (SELECT ucb_sigma_min FROM params)) *\n          ( 0.5 * (1.0 / (1.0 + LOG10(1.0 + COALESCE(sv.sent_28d,0.0))))\n          + 0.5 * (1.0 / (1.0 + LOG10(1.0 + COALESCE(pv.decayed_sent_60d,0.0)))) )\n        )\n        * e.price * SQRT( GREATEST(e.p_buy_eb*(1.0-e.p_buy_eb),0.0) / GREATEST(e.n + e.nu,1.0) )\n      )\n    ELSE 0.0 END AS se_bonus_raw,\n    (e.price * e.p_buy_eb) AS rps_eb_price\n  FROM eb e\n  LEFT JOIN slot_vol sv USING (username_page, dow, hod)\n  LEFT JOIN page_vol pv USING (username_page)\n),\n-- allow all; tiny penalty only when cooldown had to be relaxed\nallowed AS (\n  SELECT\n    u.*,\n    TRUE AS is_allowed,\n    CASE WHEN u.ok_cnt_in_slot > 0 THEN 0.0 ELSE -0.000001 * u.days_since_last_use END AS cooldown_penalty\n  FROM ucb u\n),\nscored AS (\n  SELECT\n    a.*,\n    LEAST(a.se_bonus_raw, (SELECT ucb_cap_mult FROM params) * a.rps_eb_price) AS se_bonus,\n    (a.rps_eb_price\n     + LEAST(a.se_bonus_raw, (SELECT ucb_cap_mult FROM params) * a.rps_eb_price)\n     + COALESCE(a.style_score,0.0)\n     + a.cooldown_penalty) AS score_final\n  FROM allowed a\n  WHERE a.is_allowed = TRUE\n)\nSELECT\n  username_page, slot_dt_local, dow, hod,\n  caption_id, caption_text,\n  p_buy_eb, rps_eb_price, se_bonus, style_score, is_cooldown_ok,\n  score_final,\n  ROW_NUMBER() OVER (PARTITION BY username_page, slot_dt_local ORDER BY score_final DESC, caption_id) AS rn\nFROM scored",
    "schema": [
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "slot_dt_local",
        "type": "DATETIME"
      },
      {
        "name": "dow",
        "type": "INTEGER"
      },
      {
        "name": "hod",
        "type": "INTEGER"
      },
      {
        "name": "caption_id",
        "type": "STRING"
      },
      {
        "name": "caption_text",
        "type": "STRING"
      },
      {
        "name": "p_buy_eb",
        "type": "FLOAT"
      },
      {
        "name": "rps_eb_price",
        "type": "FLOAT"
      },
      {
        "name": "se_bonus",
        "type": "FLOAT"
      },
      {
        "name": "style_score",
        "type": "FLOAT"
      },
      {
        "name": "is_cooldown_ok",
        "type": "BOOLEAN"
      },
      {
        "name": "score_final",
        "type": "FLOAT"
      },
      {
        "name": "rn",
        "type": "INTEGER"
      }
    ]
  },
  {
    "id": "v_daily_brief_today",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-03 05:32:56",
    "modified": "2025-09-03 05:32:56",
    "query": "WITH hz AS (\n  SELECT\n    l.username_std,\n    l.hod_local,\n    -- time-decay weight: recent messages count more\n    SUM(earnings_usd * EXP(-TIMESTAMP_DIFF(CURRENT_TIMESTAMP(), l.sending_ts, DAY)/60.0)) AS score\n  FROM `of-scheduler-proj.mart.v_messages_local_180d` l\n  GROUP BY l.username_std, l.hod_local\n),\nbest_hours AS (\n  SELECT username_std, ARRAY_AGG(hod_local ORDER BY score DESC LIMIT 5) AS best_hours_local\n  FROM hz\n  GROUP BY username_std\n),\nprice_band AS (\n  SELECT\n    username_std,\n    APPROX_QUANTILES(price_usd, 20)[OFFSET(8)]  AS p25,\n    APPROX_QUANTILES(price_usd, 20)[OFFSET(10)] AS p50,\n    APPROX_QUANTILES(price_usd, 20)[OFFSET(14)] AS p75\n  FROM `of-scheduler-proj.core.message_facts`\n  WHERE sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 60 DAY)\n  GROUP BY username_std\n),\nrecent_caption_use AS (\n  SELECT username_std, caption_hash, MAX(DATE(sending_ts)) AS last_used_date\n  FROM `of-scheduler-proj.core.message_facts`\n  WHERE sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 180 DAY)\n  GROUP BY username_std, caption_hash\n),\ncaption_perf AS (\n  SELECT username_std, caption_hash,\n         SUM(earnings_usd) AS cap_rev,\n         COUNT(*)          AS cap_msgs\n  FROM `of-scheduler-proj.core.message_facts`\n  WHERE caption_hash IS NOT NULL\n    AND sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 180 DAY)\n  GROUP BY username_std, caption_hash\n),\ncandidates AS (\n  SELECT\n    cd.username_std,\n    cd.caption_id,\n    cd.caption_hash,\n    cd.caption_text,\n    cd.caption_type,\n    cd.explicitness,\n    cd.theme_tags,\n    COALESCE(cp.cap_rev, 0) AS hist_revenue,\n    COALESCE(rcu.last_used_date, DATE '1900-01-01') AS last_used_date\n  FROM `of-scheduler-proj.core.caption_dim` cd\n  LEFT JOIN caption_perf cp USING (username_std, caption_hash)\n  LEFT JOIN recent_caption_use rcu USING (username_std, caption_hash)\n),\ntop_captions AS (\n  SELECT\n    username_std,\n    ARRAY_AGG(STRUCT(caption_id, caption_text, caption_type, explicitness, theme_tags, hist_revenue)\n              ORDER BY (DATE_DIFF(CURRENT_DATE(), last_used_date, DAY) >= 28) DESC,\n                       hist_revenue DESC\n              LIMIT 10) AS caption_suggestions\n  FROM candidates\n  GROUP BY username_std\n),\navoid_last7 AS (\n  SELECT username_std, ARRAY_AGG(DISTINCT caption_hash) AS avoid_caption_hashes_7d\n  FROM `of-scheduler-proj.core.message_facts`\n  WHERE sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY)\n  GROUP BY username_std\n)\nSELECT\n  p.username_std,\n  p.assigned_scheduler,\n  s.page_state,\n  s.state_note,\n  COALESCE(bh.best_hours_local, []) AS best_hours_local,\n  STRUCT(pb.p25, pb.p50, pb.p75)     AS price_band_suggested,\n  COALESCE(tc.caption_suggestions, []) AS caption_suggestions,\n  COALESCE(a.avoid_caption_hashes_7d, []) AS avoid_caption_hashes_7d\nFROM `of-scheduler-proj.core.page_dim` p\nLEFT JOIN best_hours  bh USING (username_std)\nLEFT JOIN price_band  pb USING (username_std)\nLEFT JOIN top_captions tc USING (username_std)\nLEFT JOIN avoid_last7 a  USING (username_std)\nLEFT JOIN `of-scheduler-proj.core.page_state` s USING (username_std)",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "assigned_scheduler",
        "type": "STRING"
      },
      {
        "name": "page_state",
        "type": "STRING"
      },
      {
        "name": "state_note",
        "type": "STRING"
      },
      {
        "name": "best_hours_local",
        "type": "INTEGER",
        "mode": "REPEATED"
      },
      {
        "name": "price_band_suggested",
        "type": "RECORD",
        "fields": [
          {
            "name": "p25",
            "type": "NUMERIC"
          },
          {
            "name": "p50",
            "type": "NUMERIC"
          },
          {
            "name": "p75",
            "type": "NUMERIC"
          }
        ]
      },
      {
        "name": "caption_suggestions",
        "type": "RECORD",
        "mode": "REPEATED",
        "fields": [
          {
            "name": "caption_id",
            "type": "STRING"
          },
          {
            "name": "caption_text",
            "type": "STRING"
          },
          {
            "name": "caption_type",
            "type": "STRING"
          },
          {
            "name": "explicitness",
            "type": "STRING"
          },
          {
            "name": "theme_tags",
            "type": "STRING"
          },
          {
            "name": "hist_revenue",
            "type": "NUMERIC"
          }
        ]
      },
      {
        "name": "avoid_caption_hashes_7d",
        "type": "STRING",
        "mode": "REPEATED"
      }
    ]
  },
  {
    "id": "v_daily_quota_policy_final_v1",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-13 10:08:12",
    "modified": "2025-09-13 10:08:12",
    "query": "WITH pack AS (SELECT * FROM mart.v_daily_quota_policy_from_pack_v1), legacy AS (SELECT * FROM mart.daily_quota_policy_legacy_snapshot_v3), base AS ( SELECT COALESCE(p.username_std, l.username_std) AS username_std, COALESCE(p.assigned_scheduler, l.assigned_scheduler) AS assigned_scheduler, COALESCE(p.tz, l.tz) AS tz, COALESCE(p.dow, l.dow) AS dow, COALESCE(p.ppv_quota, l.ppv_quota) AS ppv_quota_raw, COALESCE(p.hour_pool, l.hour_pool) AS hour_pool_raw, COALESCE(p.is_burst_dow, l.is_burst_dow) AS is_burst_dow, p.pack_min_hod, p.pack_max_hod, p.price_mode_default FROM pack p FULL OUTER JOIN legacy l ON l.username_std = p.username_std AND l.dow = p.dow ), manual AS ( SELECT username_std, quota_min, quota_max, hour_pool_override FROM ops_config.v_page_overrides ), learned AS ( SELECT username_std, quota_nudge, hour_pool_nudge, price_mode_bias FROM ops_config.v_page_knobs_learned_v1 ), ovr AS ( SELECT COALESCE(m.username_std, l.username_std) AS username_std, m.quota_min, m.quota_max, m.hour_pool_override, l.quota_nudge, l.hour_pool_nudge, l.price_mode_bias FROM manual m FULL OUTER JOIN learned l USING (username_std) ), nudged AS ( SELECT b.username_std, b.assigned_scheduler, b.tz, b.dow, b.is_burst_dow, CAST(b.ppv_quota_raw + COALESCE(o.quota_nudge, 0) AS INT64) AS ppv_quota_nudged, CAST(b.hour_pool_raw + COALESCE(o.hour_pool_nudge, 0) AS INT64) AS hour_pool_nudged, b.pack_min_hod, b.pack_max_hod, COALESCE(o.price_mode_bias, b.price_mode_default) AS price_mode_eff, o.quota_min, o.quota_max, o.hour_pool_override FROM base b LEFT JOIN ovr o USING (username_std) ) SELECT n.username_std, n.assigned_scheduler, n.tz, n.dow, CAST(LEAST(COALESCE(n.quota_max, 99), GREATEST(COALESCE(n.quota_min, 0), n.ppv_quota_nudged)) AS INT64) AS ppv_quota, CAST(LEAST(24, GREATEST(6, COALESCE(n.hour_pool_override, n.hour_pool_nudged))) AS INT64) AS hour_pool, CAST(COALESCE(n.is_burst_dow, 0) AS INT64) AS is_burst_dow, n.pack_min_hod, n.pack_max_hod, n.price_mode_eff FROM nudged n ORDER BY username_std, dow",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "assigned_scheduler",
        "type": "STRING"
      },
      {
        "name": "tz",
        "type": "STRING"
      },
      {
        "name": "dow",
        "type": "INTEGER"
      },
      {
        "name": "ppv_quota",
        "type": "INTEGER"
      },
      {
        "name": "hour_pool",
        "type": "INTEGER"
      },
      {
        "name": "is_burst_dow",
        "type": "INTEGER"
      },
      {
        "name": "pack_min_hod",
        "type": "INTEGER"
      },
      {
        "name": "pack_max_hod",
        "type": "INTEGER"
      },
      {
        "name": "price_mode_eff",
        "type": "STRING"
      }
    ]
  },
  {
    "id": "v_daily_quota_policy_from_pack_v1",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-13 10:08:00",
    "modified": "2025-09-13 10:08:00",
    "query": "WITH pages AS ( SELECT d.username_std, d.tz, d.assigned_scheduler, t.recommended_tier AS tier, v.page_type FROM layer_04_semantic.v_page_dim d LEFT JOIN layer_03_foundation.dim_creator c ON c.username = d.username_std AND c.is_current_record = TRUE LEFT JOIN layer_04_semantic.v_creator_tier_assignment t ON t.creator_key = c.creator_key LEFT JOIN layer_04_semantic.v_pages v USING (username_std) WHERE t.recommended_tier IS NOT NULL ), map AS ( SELECT tier, page_type, pack_id FROM ops_config.starter_pack_by_tier_v1 ), policy AS ( SELECT pack_id, dow, ppv_quota, COALESCE(hour_pool, LEAST(24, GREATEST(8, 3*ppv_quota))) AS hour_pool, min_hod, max_hod, price_mode_default, is_burst_dow FROM ops_config.starter_pack_policy_v1 ) SELECT p.username_std, p.assigned_scheduler, p.tz, pol.dow, pol.ppv_quota, pol.hour_pool, pol.is_burst_dow, pol.min_hod AS pack_min_hod, pol.max_hod AS pack_max_hod, pol.price_mode_default FROM pages p JOIN map m ON m.tier = p.tier AND (m.page_type IS NULL OR m.page_type = p.page_type) JOIN policy pol USING (pack_id)",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "assigned_scheduler",
        "type": "STRING"
      },
      {
        "name": "tz",
        "type": "STRING"
      },
      {
        "name": "dow",
        "type": "INTEGER"
      },
      {
        "name": "ppv_quota",
        "type": "INTEGER"
      },
      {
        "name": "hour_pool",
        "type": "INTEGER"
      },
      {
        "name": "is_burst_dow",
        "type": "INTEGER"
      },
      {
        "name": "pack_min_hod",
        "type": "INTEGER"
      },
      {
        "name": "pack_max_hod",
        "type": "INTEGER"
      },
      {
        "name": "price_mode_default",
        "type": "STRING"
      }
    ]
  },
  {
    "id": "v_daily_quota_policy_v3",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-07 05:55:40",
    "modified": "2025-09-07 05:55:40",
    "query": "SELECT username_std, assigned_scheduler, tz, dow, ppv_quota, hour_pool, is_burst_dow\nFROM `of-scheduler-proj.mart.v_daily_quota_policy_final_v1`",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "assigned_scheduler",
        "type": "STRING"
      },
      {
        "name": "tz",
        "type": "STRING"
      },
      {
        "name": "dow",
        "type": "INTEGER"
      },
      {
        "name": "ppv_quota",
        "type": "INTEGER"
      },
      {
        "name": "hour_pool",
        "type": "INTEGER"
      },
      {
        "name": "is_burst_dow",
        "type": "INTEGER"
      }
    ]
  },
  {
    "id": "v_dm_send_facts_v3",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-06 19:19:27",
    "modified": "2025-09-06 19:19:27",
    "query": "SELECT * FROM `of-scheduler-proj.mart.fn_dm_send_facts`(90)",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "page_type",
        "type": "STRING"
      },
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "timezone",
        "type": "STRING"
      },
      {
        "name": "sending_ts_utc",
        "type": "TIMESTAMP"
      },
      {
        "name": "sending_dt_local",
        "type": "DATETIME"
      },
      {
        "name": "dow",
        "type": "INTEGER"
      },
      {
        "name": "hod",
        "type": "INTEGER"
      },
      {
        "name": "dm_type",
        "type": "STRING"
      },
      {
        "name": "price_usd",
        "type": "NUMERIC"
      },
      {
        "name": "sent",
        "type": "INTEGER"
      },
      {
        "name": "viewed",
        "type": "INTEGER"
      },
      {
        "name": "purchased",
        "type": "INTEGER"
      },
      {
        "name": "earnings",
        "type": "NUMERIC"
      },
      {
        "name": "open_rate",
        "type": "FLOAT"
      },
      {
        "name": "buy_rate_sent",
        "type": "FLOAT"
      },
      {
        "name": "buy_rate_viewed",
        "type": "FLOAT"
      },
      {
        "name": "rps",
        "type": "NUMERIC"
      },
      {
        "name": "arppu_dm",
        "type": "NUMERIC"
      },
      {
        "name": "caption_hash",
        "type": "STRING"
      }
    ]
  },
  {
    "id": "v_dm_slot_eb_28d_v3",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-06 19:32:04",
    "modified": "2025-09-06 19:32:04",
    "query": "WITH base AS (\n  SELECT username_page, dow, hod, price_usd, sent, viewed, purchased, earnings\n  FROM `of-scheduler-proj.mart.fn_dm_send_facts`(28)\n),\nslot AS (\n  SELECT\n    username_page, dow, hod,\n    CASE\n      WHEN price_usd IS NULL OR price_usd = 0 THEN 'free'\n      WHEN price_usd < 10 THEN 'p1'\n      WHEN price_usd < 20 THEN 'p2'\n      ELSE 'p3'\n    END AS price_band,\n    COUNT(*)      AS msg_cnt,\n    SUM(sent)     AS sent_sum,\n    SUM(viewed)   AS viewed_sum,\n    SUM(purchased) AS purchased_sum,\n    SUM(earnings) AS earnings_sum\n  FROM base\n  GROUP BY 1,2,3,4\n)\nSELECT\n  s.username_page, s.dow, s.hod, s.price_band, s.msg_cnt,\n  s.sent_sum, s.viewed_sum, s.purchased_sum, s.earnings_sum,\n  SAFE_DIVIDE(s.viewed_sum    + 200 * p.mu_open,     s.sent_sum + 200) AS open_rate_eb,\n  SAFE_DIVIDE(s.purchased_sum + 200 * p.mu_buy_sent, s.sent_sum + 200) AS buy_rate_sent_eb,\n  SAFE_DIVIDE(s.earnings_sum, NULLIF(s.sent_sum,0))                    AS rps_raw,\n  SAFE_DIVIDE(s.sent_sum, s.sent_sum + 400) * SAFE_DIVIDE(s.earnings_sum, NULLIF(s.sent_sum,0))\n    + SAFE_DIVIDE(400, s.sent_sum + 400) * p.mu_rps                    AS rps_eb\nFROM slot s\nJOIN `of-scheduler-proj.mart.v_page_priors_l90_v3` p USING (username_page)",
    "schema": [
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "dow",
        "type": "INTEGER"
      },
      {
        "name": "hod",
        "type": "INTEGER"
      },
      {
        "name": "price_band",
        "type": "STRING"
      },
      {
        "name": "msg_cnt",
        "type": "INTEGER"
      },
      {
        "name": "sent_sum",
        "type": "INTEGER"
      },
      {
        "name": "viewed_sum",
        "type": "INTEGER"
      },
      {
        "name": "purchased_sum",
        "type": "INTEGER"
      },
      {
        "name": "earnings_sum",
        "type": "NUMERIC"
      },
      {
        "name": "open_rate_eb",
        "type": "FLOAT"
      },
      {
        "name": "buy_rate_sent_eb",
        "type": "FLOAT"
      },
      {
        "name": "rps_raw",
        "type": "NUMERIC"
      },
      {
        "name": "rps_eb",
        "type": "FLOAT"
      }
    ]
  },
  {
    "id": "v_dm_style_lift_28d_v3",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-06 20:09:07",
    "modified": "2025-09-06 20:09:07",
    "query": "WITH cfg AS (\n  SELECT\n    CAST(COALESCE(MAX(CASE WHEN setting_key='half_life_days_rev' THEN setting_val END), '45') AS FLOAT64) AS hl_days,\n    CAST(COALESCE(MAX(CASE WHEN setting_key='prior_k_style'      THEN setting_val END), '30') AS FLOAT64) AS k_style\n  FROM `of-scheduler-proj.core.settings_modeling`\n),\nbase AS (\n  SELECT\n    f.username_page, f.dow, f.hod, f.caption_hash, f.rps, f.sending_ts_utc,\n    `of-scheduler-proj.util.halflife_weight`(f.sending_ts_utc, (SELECT hl_days FROM cfg)) AS w\n  FROM `of-scheduler-proj.mart.fn_dm_send_facts`(28) f\n),\nslot_baseline AS (\n  SELECT\n    username_page, dow, hod,\n    SAFE_DIVIDE(SUM(rps*w), NULLIF(SUM(w),0)) AS baseline_rps,\n    SUM(w) AS slot_w\n  FROM base\n  GROUP BY 1,2,3\n),\nfeat AS (\n  SELECT\n    username_page, caption_hash, len_bin, emoji_bin, has_cta, has_urgency, ends_with_question\n  FROM `of-scheduler-proj.core.v_caption_candidates_features_v3`\n),\nagg AS (\n  SELECT\n    b.username_page, b.dow, b.hod,\n    f.len_bin, f.emoji_bin, f.has_cta, f.has_urgency, f.ends_with_question,\n    COUNT(*) AS sends,\n    SUM(b.w) AS eff_w,\n    SAFE_DIVIDE(SUM(b.rps*b.w), NULLIF(SUM(b.w),0)) AS rps_w\n  FROM base b\n  JOIN feat f\n    USING (username_page, caption_hash)\n  GROUP BY 1,2,3,4,5,6,7,8\n)\nSELECT\n  a.username_page, a.dow, a.hod,\n  a.len_bin, a.emoji_bin, a.has_cta, a.has_urgency, a.ends_with_question,\n  a.sends, a.eff_w,\n  a.rps_w,\n  sb.baseline_rps,\n  -- raw lift (decayed)\n  SAFE_DIVIDE(a.rps_w, NULLIF(sb.baseline_rps,0)) - 1 AS lift_vs_slot,\n  -- smoothed lift: shrink towards slot baseline with k_style pseudo-weight\n  SAFE_DIVIDE(\n    (a.eff_w * a.rps_w + (SELECT k_style FROM cfg) * sb.baseline_rps),\n    NULLIF(a.eff_w + (SELECT k_style FROM cfg), 0)\n  ) / NULLIF(sb.baseline_rps,0) - 1 AS lift_vs_slot_smooth,\n  -- clamped (safe) lift to avoid extreme effects\n  GREATEST(-0.50, LEAST(0.50,\n    SAFE_DIVIDE(\n      (a.eff_w * a.rps_w + (SELECT k_style FROM cfg) * sb.baseline_rps),\n      NULLIF(a.eff_w + (SELECT k_style FROM cfg), 0)\n    ) / NULLIF(sb.baseline_rps,0) - 1\n  )) AS lift_vs_slot_smooth_clamped\nFROM agg a\nJOIN slot_baseline sb\n  USING (username_page, dow, hod)",
    "schema": [
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "dow",
        "type": "INTEGER"
      },
      {
        "name": "hod",
        "type": "INTEGER"
      },
      {
        "name": "len_bin",
        "type": "STRING"
      },
      {
        "name": "emoji_bin",
        "type": "STRING"
      },
      {
        "name": "has_cta",
        "type": "BOOLEAN"
      },
      {
        "name": "has_urgency",
        "type": "BOOLEAN"
      },
      {
        "name": "ends_with_question",
        "type": "BOOLEAN"
      },
      {
        "name": "sends",
        "type": "INTEGER"
      },
      {
        "name": "eff_w",
        "type": "FLOAT"
      },
      {
        "name": "rps_w",
        "type": "FLOAT"
      },
      {
        "name": "baseline_rps",
        "type": "FLOAT"
      },
      {
        "name": "lift_vs_slot",
        "type": "FLOAT"
      },
      {
        "name": "lift_vs_slot_smooth",
        "type": "FLOAT"
      },
      {
        "name": "lift_vs_slot_smooth_clamped",
        "type": "FLOAT"
      }
    ]
  },
  {
    "id": "v_hod_heat_180d_local",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-03 01:33:37",
    "modified": "2025-09-03 01:33:37",
    "query": "SELECT\n  username_std,\n  hod_local,\n  COUNT(*) AS msg_count,\n  SUM(sent) AS w_sent,\n  SUM(viewed) AS w_viewed,\n  SUM(purchased) AS w_purchased,\n  SUM(earnings_usd) AS revenue,\n  SAFE_DIVIDE(SUM(viewed),   NULLIF(SUM(sent),0)) AS view_rate,\n  SAFE_DIVIDE(SUM(purchased),NULLIF(SUM(sent),0)) AS buy_rate,\n  SAFE_DIVIDE(SUM(earnings_usd), NULLIF(COUNT(*),0)) AS rev_per_msg\nFROM `of-scheduler-proj.mart.v_messages_local_180d`\nGROUP BY username_std, hod_local",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "hod_local",
        "type": "INTEGER"
      },
      {
        "name": "msg_count",
        "type": "INTEGER"
      },
      {
        "name": "w_sent",
        "type": "INTEGER"
      },
      {
        "name": "w_viewed",
        "type": "INTEGER"
      },
      {
        "name": "w_purchased",
        "type": "INTEGER"
      },
      {
        "name": "revenue",
        "type": "NUMERIC"
      },
      {
        "name": "view_rate",
        "type": "FLOAT"
      },
      {
        "name": "buy_rate",
        "type": "FLOAT"
      },
      {
        "name": "rev_per_msg",
        "type": "NUMERIC"
      }
    ]
  },
  {
    "id": "v_learning_signals_28d_v1",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-13 14:05:59",
    "modified": "2025-09-13 14:05:59",
    "query": "WITH mf AS (\n  SELECT\n    username_std,\n    DATE(TIMESTAMP_TRUNC(sending_ts, DAY)) AS d,\n    SAFE_CAST(price_usd    AS NUMERIC) AS price_usd,\n    SAFE_CAST(earnings_usd AS NUMERIC) AS earnings_usd\n  FROM `of-scheduler-proj.layer_04_semantic.message_facts`\n  WHERE sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 28 DAY)\n),\nby_page AS (\n  SELECT\n    username_std,\n    COUNT(*) AS sends_28d,\n    SUM(earnings_usd) AS earnings_28d,\n    SAFE_DIVIDE(SUM(earnings_usd), COUNT(*)) AS rps_28d,\n    APPROX_QUANTILES(price_usd, 101)[OFFSET(50)] AS p50_price,\n    COUNTIF(earnings_usd > 0) / COUNT(*) AS sell_rate\n  FROM mf\n  GROUP BY username_std\n),\ntrend AS (\n  SELECT\n    a.username_std,\n    SAFE_DIVIDE(a.earnings, GREATEST(a.sends,1)) AS rps_recent,\n    SAFE_DIVIDE(b.earnings, GREATEST(b.sends,1)) AS rps_prev,\n    SAFE_DIVIDE(a.earnings - b.earnings, NULLIF(b.earnings,0)) AS earnings_lift_ratio\n  FROM (\n    SELECT username_std, COUNT(*) AS sends, SUM(earnings_usd) AS earnings\n    FROM mf\n    WHERE d >= DATE_SUB(CURRENT_DATE(), INTERVAL 14 DAY)\n    GROUP BY username_std\n  ) a\n  FULL JOIN (\n    SELECT username_std, COUNT(*) AS sends, SUM(earnings_usd) AS earnings\n    FROM mf\n    WHERE d < DATE_SUB(CURRENT_DATE(), INTERVAL 14 DAY)\n      AND d >= DATE_SUB(CURRENT_DATE(), INTERVAL 28 DAY)\n    GROUP BY username_std\n  ) b USING (username_std)\n)\nSELECT\n  p.username_std, p.sends_28d, p.earnings_28d, p.rps_28d, p.p50_price, p.sell_rate,\n  t.rps_recent, t.rps_prev, t.earnings_lift_ratio\nFROM by_page p\nLEFT JOIN trend t USING (username_std)",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "sends_28d",
        "type": "INTEGER"
      },
      {
        "name": "earnings_28d",
        "type": "NUMERIC"
      },
      {
        "name": "rps_28d",
        "type": "NUMERIC"
      },
      {
        "name": "p50_price",
        "type": "NUMERIC"
      },
      {
        "name": "sell_rate",
        "type": "FLOAT"
      },
      {
        "name": "rps_recent",
        "type": "NUMERIC"
      },
      {
        "name": "rps_prev",
        "type": "NUMERIC"
      },
      {
        "name": "earnings_lift_ratio",
        "type": "NUMERIC"
      }
    ]
  },
  {
    "id": "v_messages_active_180d",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-13 14:06:05",
    "modified": "2025-09-13 14:06:05",
    "query": "SELECT m.*\nFROM `of-scheduler-proj.layer_04_semantic.message_facts` m\nJOIN `of-scheduler-proj.layer_04_semantic.v_page_dim` p USING (username_std)\nWHERE m.sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 180 DAY)",
    "schema": [
      {
        "name": "row_key_v1",
        "type": "STRING"
      },
      {
        "name": "message_id",
        "type": "STRING"
      },
      {
        "name": "username_raw",
        "type": "STRING"
      },
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "sender",
        "type": "STRING"
      },
      {
        "name": "sending_ts",
        "type": "TIMESTAMP"
      },
      {
        "name": "sending_date",
        "type": "DATE"
      },
      {
        "name": "price_usd",
        "type": "NUMERIC"
      },
      {
        "name": "earnings_usd",
        "type": "NUMERIC"
      },
      {
        "name": "sent",
        "type": "INTEGER"
      },
      {
        "name": "viewed",
        "type": "INTEGER"
      },
      {
        "name": "purchased",
        "type": "INTEGER"
      },
      {
        "name": "caption_hash",
        "type": "STRING"
      },
      {
        "name": "source_file",
        "type": "STRING"
      },
      {
        "name": "loaded_at",
        "type": "TIMESTAMP"
      }
    ]
  },
  {
    "id": "v_messages_local_180d",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-13 14:06:12",
    "modified": "2025-09-13 14:06:12",
    "query": "SELECT\n  m.*,\n  DATETIME(m.sending_ts, p.tz) AS dt_local,\n  EXTRACT(HOUR FROM DATETIME(m.sending_ts, p.tz)) AS hod_local,\n  MOD(EXTRACT(DAYOFWEEK FROM DATETIME(m.sending_ts, p.tz)) + 5, 7) AS dow_local  -- Mon=0..Sun=6\nFROM `of-scheduler-proj.layer_04_semantic.message_facts` m\nJOIN `of-scheduler-proj.layer_04_semantic.v_page_dim` p USING (username_std)\nWHERE m.sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 180 DAY)",
    "schema": [
      {
        "name": "row_key_v1",
        "type": "STRING"
      },
      {
        "name": "message_id",
        "type": "STRING"
      },
      {
        "name": "username_raw",
        "type": "STRING"
      },
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "sender",
        "type": "STRING"
      },
      {
        "name": "sending_ts",
        "type": "TIMESTAMP"
      },
      {
        "name": "sending_date",
        "type": "DATE"
      },
      {
        "name": "price_usd",
        "type": "NUMERIC"
      },
      {
        "name": "earnings_usd",
        "type": "NUMERIC"
      },
      {
        "name": "sent",
        "type": "INTEGER"
      },
      {
        "name": "viewed",
        "type": "INTEGER"
      },
      {
        "name": "purchased",
        "type": "INTEGER"
      },
      {
        "name": "caption_hash",
        "type": "STRING"
      },
      {
        "name": "source_file",
        "type": "STRING"
      },
      {
        "name": "loaded_at",
        "type": "TIMESTAMP"
      },
      {
        "name": "dt_local",
        "type": "DATETIME"
      },
      {
        "name": "hod_local",
        "type": "INTEGER"
      },
      {
        "name": "dow_local",
        "type": "INTEGER"
      }
    ]
  },
  {
    "id": "v_mm_base_180d",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-13 14:06:19",
    "modified": "2025-09-13 14:06:19",
    "query": "SELECT\n  LOWER(TRIM(m.username_std)) AS username_std,\n  m.sending_ts,\n  DATETIME(m.sending_ts, p.tz) AS sending_dt_local,\n  DATE(m.sending_ts, p.tz)     AS date_local,\n  EXTRACT(HOUR FROM DATETIME(m.sending_ts, p.tz)) AS hod_local,\n  MOD(EXTRACT(DAYOFWEEK FROM DATE(m.sending_ts, p.tz)) + 5, 7) AS dow_local,  -- Mon=0..Sun=6\n  SAFE_CAST(m.price_usd    AS FLOAT64) AS price_usd,\n  SAFE_CAST(m.earnings_usd AS FLOAT64) AS earnings_usd,\n  SAFE_CAST(m.sent         AS INT64)   AS sent,\n  SAFE_CAST(m.viewed       AS INT64)   AS viewed,\n  SAFE_CAST(m.purchased    AS INT64)   AS purchased,\n  CASE WHEN m.price_usd IS NOT NULL AND m.price_usd > 0 THEN 1 ELSE 0 END AS is_ppv\nFROM `of-scheduler-proj.layer_04_semantic.message_facts` m\nJOIN `of-scheduler-proj.layer_04_semantic.v_page_dim` p USING (username_std)\nWHERE m.sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 180 DAY)",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "sending_ts",
        "type": "TIMESTAMP"
      },
      {
        "name": "sending_dt_local",
        "type": "DATETIME"
      },
      {
        "name": "date_local",
        "type": "DATE"
      },
      {
        "name": "hod_local",
        "type": "INTEGER"
      },
      {
        "name": "dow_local",
        "type": "INTEGER"
      },
      {
        "name": "price_usd",
        "type": "FLOAT"
      },
      {
        "name": "earnings_usd",
        "type": "FLOAT"
      },
      {
        "name": "sent",
        "type": "INTEGER"
      },
      {
        "name": "viewed",
        "type": "INTEGER"
      },
      {
        "name": "purchased",
        "type": "INTEGER"
      },
      {
        "name": "is_ppv",
        "type": "INTEGER"
      }
    ]
  },
  {
    "id": "v_mm_dow_hod_180d_local_v2",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-03 16:58:34",
    "modified": "2025-09-03 16:58:34",
    "query": "WITH b AS (\n  SELECT\n    username_std,\n    sending_ts,\n    date_local,\n    dow_local,\n    hod_local,\n    price_usd,\n    earnings_usd,\n    sent,\n    viewed,\n    purchased,\n    is_ppv\n  FROM `of-scheduler-proj.mart.v_mm_base_180d`\n),\nby_slot AS (\n  SELECT\n    username_std,\n    dow_local,\n    hod_local,\n    COUNT(*)                                                AS message_events,     -- count of MM sends (events)\n    SUM(sent)                                               AS sent,               -- total recipients\n    SUM(viewed)                                             AS viewed,\n    SUM(purchased)                                          AS purchased,\n    SUM(earnings_usd)                                       AS revenue,\n    SAFE_DIVIDE(SUM(viewed),    NULLIF(SUM(sent), 0))       AS view_rate,\n    SAFE_DIVIDE(SUM(purchased), NULLIF(SUM(sent), 0))       AS purchase_rate,\n    SAFE_DIVIDE(SUM(earnings_usd), NULLIF(SUM(sent), 0))    AS rev_per_recipient,  -- $ per delivered recipient\n    SAFE_DIVIDE(SUM(earnings_usd), NULLIF(COUNT(*), 0))     AS rev_per_send,       -- $ per MM event\n    -- 45-day half-life recency decay on revenue\n    SUM(earnings_usd * EXP(-TIMESTAMP_DIFF(CURRENT_TIMESTAMP(), sending_ts, DAY)/45.0)) AS score\n  FROM b\n  GROUP BY username_std, dow_local, hod_local\n),\nstability AS (\n  -- how many distinct days contributed to this slot (useful for filtering thin data)\n  SELECT\n    username_std,\n    dow_local,\n    hod_local,\n    COUNT(*) AS days_covered\n  FROM (\n    SELECT DISTINCT username_std, dow_local, hod_local, date_local\n    FROM b\n  )\n  GROUP BY username_std, dow_local, hod_local\n)\nSELECT\n  s.username_std,\n  s.dow_local,\n  s.hod_local,\n  s.message_events,\n  s.sent,\n  s.viewed,\n  s.purchased,\n  s.revenue,\n  s.view_rate,\n  s.purchase_rate,\n  s.rev_per_recipient,\n  s.rev_per_send,\n  s.score,\n  st.days_covered\nFROM by_slot s\nLEFT JOIN stability st\n  ON st.username_std = s.username_std\n AND st.dow_local    = s.dow_local\n AND st.hod_local    = s.hod_local",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "dow_local",
        "type": "INTEGER"
      },
      {
        "name": "hod_local",
        "type": "INTEGER"
      },
      {
        "name": "message_events",
        "type": "INTEGER"
      },
      {
        "name": "sent",
        "type": "INTEGER"
      },
      {
        "name": "viewed",
        "type": "INTEGER"
      },
      {
        "name": "purchased",
        "type": "INTEGER"
      },
      {
        "name": "revenue",
        "type": "FLOAT"
      },
      {
        "name": "view_rate",
        "type": "FLOAT"
      },
      {
        "name": "purchase_rate",
        "type": "FLOAT"
      },
      {
        "name": "rev_per_recipient",
        "type": "FLOAT"
      },
      {
        "name": "rev_per_send",
        "type": "FLOAT"
      },
      {
        "name": "score",
        "type": "FLOAT"
      },
      {
        "name": "days_covered",
        "type": "INTEGER"
      }
    ]
  },
  {
    "id": "v_mm_price_profile_90d_v2",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-05 03:39:31",
    "modified": "2025-09-05 03:39:31",
    "query": "WITH f AS (\n  SELECT\n    username_std,\n    price_usd,\n    earnings_usd\n  FROM `of-scheduler-proj.mart.v_mm_base_180d`\n  WHERE sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 90 DAY)\n    AND price_usd IS NOT NULL\n),\nagg AS (\n  SELECT\n    username_std,\n    APPROX_QUANTILES(price_usd, 20)[OFFSET(6)]  AS p35,\n    APPROX_QUANTILES(price_usd, 20)[OFFSET(10)] AS p50,\n    APPROX_QUANTILES(price_usd, 20)[OFFSET(12)] AS p60,\n    APPROX_QUANTILES(price_usd, 20)[OFFSET(15)] AS p80,\n    APPROX_QUANTILES(price_usd, 20)[OFFSET(17)] AS p90,\n    CORR(price_usd, earnings_usd)               AS corr\n  FROM f\n  GROUP BY username_std\n)\nSELECT\n  username_std,\n  p35, p50, p60, p80, p90,\n  corr AS corr_price_rev,\n  CASE\n    WHEN corr >=  0.25 THEN 'premium'\n    WHEN corr <= -0.15 THEN 'value'\n    ELSE 'balanced'\n  END AS price_mode\nFROM agg",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "p35",
        "type": "FLOAT"
      },
      {
        "name": "p50",
        "type": "FLOAT"
      },
      {
        "name": "p60",
        "type": "FLOAT"
      },
      {
        "name": "p80",
        "type": "FLOAT"
      },
      {
        "name": "p90",
        "type": "FLOAT"
      },
      {
        "name": "corr_price_rev",
        "type": "FLOAT"
      },
      {
        "name": "price_mode",
        "type": "STRING"
      }
    ]
  },
  {
    "id": "v_non_dm_windows_7d_v1",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-07 01:50:24",
    "modified": "2025-09-07 01:50:24",
    "query": "WITH cfg AS (\n  SELECT\n    -- CSVs from settings\n    (SELECT setting_val FROM `of-scheduler-proj.core.settings_modeling`\n     WHERE setting_key='drip_slots_csv'        LIMIT 1) AS drip_csv,\n    (SELECT setting_val FROM `of-scheduler-proj.core.settings_modeling`\n     WHERE setting_key='renewal_times_csv'     LIMIT 1) AS renew_csv,\n    (SELECT setting_val FROM `of-scheduler-proj.core.settings_modeling`\n     WHERE setting_key='link_drop_times_csv'   LIMIT 1) AS link_csv,\n    CAST((SELECT setting_val FROM `of-scheduler-proj.core.settings_modeling`\n          WHERE setting_key='randomize_offset_minutes' LIMIT 1) AS INT64) AS rand_off\n),\npages AS (\n  SELECT username_std, COALESCE(tz,'UTC') AS tz\n  FROM `of-scheduler-proj.core.page_dim`\n  WHERE COALESCE(LOWER(CAST(is_active AS STRING)) IN ('true','t','1','yes','y'), TRUE)\n),\ndays AS (\n  SELECT p.username_std, p.tz,\n         DATE_ADD(CURRENT_DATE(p.tz), INTERVAL d DAY) AS d,\n         d AS day_idx\n  FROM pages p\n  CROSS JOIN UNNEST(GENERATE_ARRAY(0,6)) AS d\n),\n-- mark paid (renewals only for these)\npaid AS (\n  SELECT username_std, COALESCE(renew_on_pct,0) > 0 AS is_paid\n  FROM `of-scheduler-proj.staging.creator_stats_latest`\n),\n\n/* -------- DripSet: \"HH:MM|TYPE\" where TYPE in {MM, Wall} -------- */\ndrip_tokens AS (\n  SELECT\n    dt.username_std, dt.tz, dt.d, dt.day_idx,\n    SPLIT(tok, '|')[OFFSET(0)] AS hhmm,\n    SPLIT(tok, '|')[OFFSET(1)] AS ch   -- 'MM' or 'Wall'\n  FROM days dt, cfg, UNNEST(SPLIT(cfg.drip_csv, ',')) AS tok\n),\ndrip AS (\n  SELECT\n    username_std,\n    -- local DATETIME (no tz arg)\n    DATETIME(d, PARSE_TIME('%H:%M', hhmm)) AS base_dt_local,\n    ch AS channel,  -- 'MM' or 'Wall'\n    -- deterministic jitter in [-rand_off, +rand_off]\n    CAST(\n      MOD(ABS(FARM_FINGERPRINT(CONCAT(username_std,'|',CAST(d AS STRING),'|DRIP|',hhmm,'|',ch))),\n          2*(SELECT rand_off FROM cfg)+1\n      ) - (SELECT rand_off FROM cfg)\n      AS INT64\n    ) AS minute_jitter,\n    tz\n  FROM drip_tokens\n),\n\n/* -------- Renewals: paid pages only, times listed in renew_csv -------- */\nrenew_tokens AS (\n  SELECT dt.username_std, dt.tz, dt.d, dt.day_idx, tok AS hhmm\n  FROM days dt, cfg, UNNEST(SPLIT(cfg.renew_csv, ',')) AS tok\n  JOIN paid p USING (username_std)\n  WHERE p.is_paid = TRUE\n),\nrenew AS (\n  SELECT\n    username_std,\n    DATETIME(d, PARSE_TIME('%H:%M', hhmm)) AS base_dt_local,\n    'Renewal' AS channel,\n    CAST(\n      MOD(ABS(FARM_FINGERPRINT(CONCAT(username_std,'|',CAST(d AS STRING),'|RENEW|',hhmm))),\n          2*(SELECT rand_off FROM cfg)+1\n      ) - (SELECT rand_off FROM cfg)\n      AS INT64\n    ) AS minute_jitter,\n    tz\n  FROM renew_tokens\n),\n\n/* -------- Link drops: windows like \"HH:MM-HH:MM\" â†’ pick a minute inside -------- */\nlink_tokens AS (\n  SELECT\n    dt.username_std, dt.tz, dt.d, dt.day_idx,\n    SPLIT(tok, '-')[OFFSET(0)] AS hhmm_start,\n    SPLIT(tok, '-')[OFFSET(1)] AS hhmm_end\n  FROM days dt, cfg, UNNEST(SPLIT(cfg.link_csv, ',')) AS tok\n),\nlink_picked AS (\n  SELECT\n    lt.username_std,\n    -- local window start/end as DATETIME (no tz)\n    DATETIME(lt.d, PARSE_TIME('%H:%M', lt.hhmm_start)) AS win_start_dt,\n    DATETIME(lt.d, PARSE_TIME('%H:%M', lt.hhmm_end))   AS win_end_dt,\n    'LinkDrop' AS channel,\n    lt.tz\n  FROM link_tokens lt\n),\nlink_final AS (\n  SELECT\n    username_std,\n    DATETIME_ADD(win_start_dt,\n      INTERVAL CAST(MOD(\n        ABS(FARM_FINGERPRINT(CONCAT(username_std,'|',CAST(win_start_dt AS STRING),'|link'))),\n        GREATEST(DATETIME_DIFF(win_end_dt, win_start_dt, MINUTE), 1)\n      ) AS INT64) MINUTE\n    ) AS base_dt_local,\n    'LinkDrop' AS channel,\n    0 AS minute_jitter,\n    tz\n  FROM link_picked\n),\n\n/* -------- Union + compute outputs -------- */\nunioned AS (\n  SELECT * FROM drip\n  UNION ALL SELECT * FROM renew\n  UNION ALL SELECT * FROM link_final\n),\nwith_dt AS (\n  SELECT\n    u.username_std,\n    -- final local datetime\n    DATETIME_ADD(u.base_dt_local, INTERVAL u.minute_jitter MINUTE) AS planned_local_datetime,\n    u.channel,\n    u.tz\n  FROM unioned u\n)\nSELECT\n  w.username_std,\n  DATE(w.planned_local_datetime) AS date_local,\n  EXTRACT(HOUR FROM w.planned_local_datetime) AS hod_local,\n  -- map channel to a normalized kind for ops\n  CASE\n    WHEN w.channel='MM'    THEN 'drip_mm'\n    WHEN w.channel='Wall'  THEN 'drip_wall'\n    WHEN w.channel='Renewal' THEN 'renewal'\n    ELSE 'link_drop'\n  END AS slot_kind,\n  w.channel,\n  w.planned_local_datetime,\n  -- if you need UTC for automation, compute it here\n  TIMESTAMP(w.planned_local_datetime, w.tz) AS scheduled_datetime_utc\nFROM with_dt w\nORDER BY username_std, planned_local_datetime, slot_kind",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "date_local",
        "type": "DATE"
      },
      {
        "name": "hod_local",
        "type": "INTEGER"
      },
      {
        "name": "slot_kind",
        "type": "STRING"
      },
      {
        "name": "channel",
        "type": "STRING"
      },
      {
        "name": "planned_local_datetime",
        "type": "DATETIME"
      },
      {
        "name": "scheduled_datetime_utc",
        "type": "TIMESTAMP"
      }
    ]
  },
  {
    "id": "v_page_priors_l90_v3",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-06 19:30:00",
    "modified": "2025-09-06 19:30:00",
    "query": "SELECT\n  username_page,\n  SUM(viewed)    AS viewed_sum,\n  SUM(sent)      AS sent_sum,\n  SUM(purchased) AS purchased_sum,\n  SAFE_DIVIDE(SUM(viewed),    NULLIF(SUM(sent),0)) AS mu_open,\n  SAFE_DIVIDE(SUM(purchased), NULLIF(SUM(sent),0)) AS mu_buy_sent,\n  SAFE_DIVIDE(SUM(earnings),  NULLIF(SUM(sent),0)) AS mu_rps\nFROM `of-scheduler-proj.mart.fn_dm_send_facts`(90)\nGROUP BY 1",
    "schema": [
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "viewed_sum",
        "type": "INTEGER"
      },
      {
        "name": "sent_sum",
        "type": "INTEGER"
      },
      {
        "name": "purchased_sum",
        "type": "INTEGER"
      },
      {
        "name": "mu_open",
        "type": "FLOAT"
      },
      {
        "name": "mu_buy_sent",
        "type": "FLOAT"
      },
      {
        "name": "mu_rps",
        "type": "NUMERIC"
      }
    ]
  },
  {
    "id": "v_page_volume_profile_28d",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-13 14:06:30",
    "modified": "2025-09-13 14:06:30",
    "query": "WITH daily AS (\n  SELECT mf.username_std,\n         DATE(mf.sending_ts, pd.tz) AS date_local,\n         COUNTIF(mf.price_usd > 0) AS ppv_cnt,\n         SUM(CASE WHEN mf.price_usd > 0 THEN mf.earnings_usd ELSE 0 END) AS rev_ppv\n  FROM `of-scheduler-proj.layer_04_semantic.message_facts` mf\n  JOIN `of-scheduler-proj.layer_04_semantic.v_page_dim` pd USING (username_std)\n  WHERE mf.sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 28 DAY)\n  GROUP BY mf.username_std, date_local\n),\nelastic AS (\n  SELECT\n    username_std,\n    AVG(ppv_cnt) AS avg_ppv_per_day,\n    APPROX_QUANTILES(ppv_cnt, 20)[OFFSET(18)] AS q90_ppv_per_day,\n    CORR(ppv_cnt, rev_ppv) AS corr_vol_rev,\n    CASE WHEN VAR_POP(ppv_cnt)=0 THEN 0\n         ELSE COVAR_POP(ppv_cnt, rev_ppv)/VAR_POP(ppv_cnt) END AS slope_rev_per_ppv\n  FROM daily GROUP BY username_std\n),\nsends AS (\n  SELECT mf.username_std,\n         DATE(mf.sending_ts, pd.tz) AS date_local,\n         ROW_NUMBER() OVER (PARTITION BY mf.username_std, DATE(mf.sending_ts, pd.tz) ORDER BY mf.sending_ts) AS rn,\n         COUNT(*) OVER  (PARTITION BY mf.username_std, DATE(mf.sending_ts, pd.tz)) AS n_sends,\n         CASE WHEN mf.price_usd > 0 THEN mf.earnings_usd ELSE 0 END AS rev\n  FROM `of-scheduler-proj.layer_04_semantic.message_facts` mf\n  JOIN `of-scheduler-proj.layer_04_semantic.v_page_dim` pd USING (username_std)\n  WHERE mf.sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 28 DAY)\n    AND mf.price_usd > 0\n),\nfatigue AS (\n  SELECT username_std,\n         SAFE_DIVIDE(AVG(CASE WHEN rn=n_sends THEN rev END),\n                     NULLIF(AVG(CASE WHEN rn=1 THEN rev END),0)) AS fatigue_ratio\n  FROM sends WHERE n_sends >= 2 GROUP BY username_std\n)\nSELECT\n  e.username_std,\n  e.avg_ppv_per_day,\n  e.q90_ppv_per_day,\n  e.corr_vol_rev,\n  e.slope_rev_per_ppv,\n  COALESCE(f.fatigue_ratio,1.0) AS fatigue_ratio,\n  CASE\n    WHEN e.slope_rev_per_ppv >= 12 AND COALESCE(f.fatigue_ratio,1.0) >= 0.70 THEN 1.50\n    WHEN e.slope_rev_per_ppv >=  8 AND COALESCE(f.fatigue_ratio,1.0) >= 0.65 THEN 1.30\n    WHEN e.slope_rev_per_ppv >=  4                                    THEN 1.15\n    WHEN e.slope_rev_per_ppv <=  1 OR COALESCE(f.fatigue_ratio,1.0) < 0.50 THEN 0.90\n    ELSE 1.00\n  END AS volume_boost\nFROM elastic e LEFT JOIN fatigue f USING (username_std)",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "avg_ppv_per_day",
        "type": "FLOAT"
      },
      {
        "name": "q90_ppv_per_day",
        "type": "INTEGER"
      },
      {
        "name": "corr_vol_rev",
        "type": "FLOAT"
      },
      {
        "name": "slope_rev_per_ppv",
        "type": "FLOAT"
      },
      {
        "name": "fatigue_ratio",
        "type": "NUMERIC"
      },
      {
        "name": "volume_boost",
        "type": "FLOAT"
      }
    ]
  },
  {
    "id": "v_page_volume_profile_28d_v2",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-03 17:01:25",
    "modified": "2025-09-03 17:01:25",
    "query": "WITH daily AS (\n  SELECT\n    username_std,\n    date_local,\n    COUNT(*)                          AS sends,\n    SUM(is_ppv)                       AS ppv_attempts,\n    SUM(sent)                         AS sent,\n    SUM(purchased)                    AS purchased,\n    SUM(earnings_usd)                 AS revenue\n  FROM `of-scheduler-proj.mart.v_mm_base_180d`\n  WHERE date_local >= DATE_SUB(CURRENT_DATE(), INTERVAL 28 DAY)\n  GROUP BY username_std, date_local\n),\nagg AS (\n  SELECT\n    username_std,\n    COUNT(*)                                        AS days_active_28d,\n    SUM(sends)                                      AS sends_28d,\n    SUM(ppv_attempts)                               AS ppv_attempts_28d,\n    SUM(sent)                                       AS sent_28d,\n    SUM(purchased)                                  AS purchased_28d,\n    SUM(revenue)                                    AS earnings_28d,\n    AVG(ppv_attempts)                               AS avg_ppv_per_day,\n    APPROX_QUANTILES(ppv_attempts, 100)[OFFSET(90)] AS q90_ppv_per_day,\n    SAFE_DIVIDE(SUM(purchased), NULLIF(SUM(ppv_attempts),0)) AS buy_rate_ppv_28d,\n    SAFE_DIVIDE(SUM(revenue),   NULLIF(SUM(sends),0))        AS rev_per_send_28d\n  FROM daily\n  GROUP BY username_std\n),\nglobals AS (\n  SELECT\n    APPROX_QUANTILES(avg_ppv_per_day, 100)[OFFSET(80)] AS p80_avg_ppv\n  FROM agg\n)\nSELECT\n  a.*,\n  -- normalized multiplier around peer p80 (clamped)\n  LEAST(1.4, GREATEST(0.8,\n    1.0 + (SAFE_DIVIDE(a.avg_ppv_per_day, NULLIF(g.p80_avg_ppv,0)) - 1.0) * 0.5\n  )) AS volume_boost,\n  -- suggested quota bounds used downstream (still clamped again there)\n  GREATEST(1, CAST(ROUND(a.avg_ppv_per_day + 1) AS INT64))                      AS qmin_suggest,\n  LEAST(6, GREATEST(3, CAST(ROUND(a.q90_ppv_per_day + 1) AS INT64)))            AS qmax_suggest\nFROM agg a\nCROSS JOIN globals g",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "days_active_28d",
        "type": "INTEGER"
      },
      {
        "name": "sends_28d",
        "type": "INTEGER"
      },
      {
        "name": "ppv_attempts_28d",
        "type": "INTEGER"
      },
      {
        "name": "sent_28d",
        "type": "INTEGER"
      },
      {
        "name": "purchased_28d",
        "type": "INTEGER"
      },
      {
        "name": "earnings_28d",
        "type": "FLOAT"
      },
      {
        "name": "avg_ppv_per_day",
        "type": "FLOAT"
      },
      {
        "name": "q90_ppv_per_day",
        "type": "INTEGER"
      },
      {
        "name": "buy_rate_ppv_28d",
        "type": "FLOAT"
      },
      {
        "name": "rev_per_send_28d",
        "type": "FLOAT"
      },
      {
        "name": "volume_boost",
        "type": "FLOAT"
      },
      {
        "name": "qmin_suggest",
        "type": "INTEGER"
      },
      {
        "name": "qmax_suggest",
        "type": "INTEGER"
      }
    ]
  },
  {
    "id": "v_plan_export_next_7d",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-03 21:28:17",
    "modified": "2025-09-03 21:28:17",
    "query": "SELECT\n  username_std,\n  scheduler_name,\n  tz,\n  date_local,\n  slot_rank,\n  hod_local,\n  price_usd,\n  planned_local_datetime,\n  scheduled_datetime_utc,\n  FORMAT_TIMESTAMP('%Y-%m-%d %H:%M:%S %Z', scheduled_datetime_utc) AS scheduled_utc_str,\n  FORMAT_DATETIME('%Y-%m-%d %H:%M', planned_local_datetime)        AS local_str\nFROM `of-scheduler-proj.mart.weekly_template_7d_latest`\nORDER BY username_std, date_local, slot_rank",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "scheduler_name",
        "type": "STRING"
      },
      {
        "name": "tz",
        "type": "STRING"
      },
      {
        "name": "date_local",
        "type": "DATE"
      },
      {
        "name": "slot_rank",
        "type": "INTEGER"
      },
      {
        "name": "hod_local",
        "type": "INTEGER"
      },
      {
        "name": "price_usd",
        "type": "FLOAT"
      },
      {
        "name": "planned_local_datetime",
        "type": "DATETIME"
      },
      {
        "name": "scheduled_datetime_utc",
        "type": "TIMESTAMP"
      },
      {
        "name": "scheduled_utc_str",
        "type": "STRING"
      },
      {
        "name": "local_str",
        "type": "STRING"
      }
    ]
  },
  {
    "id": "v_ppv_followup_bumps_v1",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-13 14:06:36",
    "modified": "2025-09-13 14:06:36",
    "query": "WITH cfg AS (\n  SELECT\n    CAST(COALESCE(MAX(IF(setting_key = 'randomize_offset_minutes', setting_val, NULL)), '45') AS INT64) AS jitter_m\n  FROM `of-scheduler-proj.ops_config.settings_modeling`\n),\nppv AS (\n  SELECT t.username_std, t.tz, t.date_local, t.slot_rank, t.hod_local, t.price_usd\n  FROM `of-scheduler-proj.mart.weekly_template_7d_latest` t\n  WHERE t.price_usd > 0\n),\nlevel AS (\n  SELECT\n    p.*,\n    CASE\n      WHEN p.price_usd >= COALESCE(pr.p90, p.price_usd) THEN 'premium'\n      WHEN p.price_usd >= COALESCE(pr.p50, p.price_usd) THEN 'mid'\n      ELSE 'teaser'\n    END AS ppv_level\n  FROM ppv p\n  LEFT JOIN `of-scheduler-proj.mart.v_mm_price_profile_90d_v2` pr USING (username_std)\n),\nrules AS (\n  -- order_i = 0 are \"pre\" bumps; positive order_i are follow-ups\n  SELECT 'teaser'   AS lvl, 0 AS order_i, -9999 AS min_off, -9999 AS max_off, FALSE AS is_real  -- no pre for teaser\n  UNION ALL SELECT 'teaser', 1,  20,  45, TRUE\n  UNION ALL SELECT 'mid',    0, -20, -15, TRUE\n  UNION ALL SELECT 'mid',    1,  15,  20, TRUE\n  UNION ALL SELECT 'mid',    2,  45,  45, TRUE\n  UNION ALL SELECT 'premium',0, -20, -15, TRUE\n  UNION ALL SELECT 'premium',1,  20,  30, TRUE\n  UNION ALL SELECT 'premium',2,  40,  55, TRUE\n),\nbase AS (\n  SELECT\n    l.username_std,\n    l.tz,\n    l.date_local,\n    l.slot_rank,\n    l.hod_local,\n    l.ppv_level,\n    r.order_i,\n    r.is_real,\n    DATETIME(l.date_local, TIME(l.hod_local, 0, 0)) AS base_slot_dt_local,\n\n    -- Deterministic pick in [min_off, max_off] using a stable key\n    CAST(ROUND(\n      r.min_off + MOD(\n        ABS(FARM_FINGERPRINT(CONCAT(\n          CAST(l.username_std AS STRING),'|',\n          CAST(l.date_local   AS STRING),'|',\n          CAST(l.slot_rank    AS STRING),'|',\n          CAST(r.order_i      AS STRING)\n        ))),\n        (r.max_off - r.min_off + 1)\n      )\n    ) AS INT64) AS picked_min\n  FROM level l\n  JOIN rules r ON r.lvl = l.ppv_level\n  WHERE r.is_real = TRUE\n),\nexpanded AS (\n  SELECT\n    b.*,\n    DATETIME_ADD(b.base_slot_dt_local, INTERVAL b.picked_min MINUTE) AS planned_dt_local\n  FROM base b\n),\njittered AS (\n  SELECT\n    e.*,\n    -- Deterministic jitter in [-jitter_m, +jitter_m] using a separate key namespace (\"|J\")\n    DATETIME_ADD(\n      e.planned_dt_local,\n      INTERVAL CAST(\n        MOD(\n          ABS(FARM_FINGERPRINT(CONCAT(\n            CAST(e.username_std AS STRING),'|',\n            CAST(e.date_local   AS STRING),'|',\n            CAST(e.slot_rank    AS STRING),'|',\n            CAST(e.order_i      AS STRING),'|','J'\n          ))),\n          (2 * (SELECT jitter_m FROM cfg) + 1)\n        ) - (SELECT jitter_m FROM cfg) AS INT64\n      ) MINUTE\n    ) AS planned_dt_local_j\n  FROM expanded e\n)\nSELECT\n  j.username_std,\n  j.date_local,\n  j.slot_rank,\n  j.ppv_level AS ppv_level,\n  CASE WHEN j.order_i = 0 AND j.ppv_level IN ('mid','premium') THEN 'ppv_pre_teaser'\n       ELSE 'ppv_followup' END AS activity_type,\n  EXTRACT(HOUR   FROM j.planned_dt_local_j) AS hod_local,\n  EXTRACT(MINUTE FROM j.planned_dt_local_j) AS minute_local,\n  j.planned_dt_local_j AS planned_local_datetime,\n  TIMESTAMP(j.planned_dt_local_j, pd.tz)    AS scheduled_datetime_utc\nFROM jittered j\nJOIN `of-scheduler-proj.layer_04_semantic.v_page_dim` pd USING (username_std)",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "date_local",
        "type": "DATE"
      },
      {
        "name": "slot_rank",
        "type": "INTEGER"
      },
      {
        "name": "ppv_level",
        "type": "STRING"
      },
      {
        "name": "activity_type",
        "type": "STRING"
      },
      {
        "name": "hod_local",
        "type": "INTEGER"
      },
      {
        "name": "minute_local",
        "type": "INTEGER"
      },
      {
        "name": "planned_local_datetime",
        "type": "DATETIME"
      },
      {
        "name": "scheduled_datetime_utc",
        "type": "TIMESTAMP"
      }
    ]
  },
  {
    "id": "v_ppv_price_curve_28d_v3",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-06 19:37:40",
    "modified": "2025-09-06 19:37:40",
    "query": "WITH ppv AS (\n  SELECT * FROM `of-scheduler-proj.mart.fn_dm_send_facts`(28)\n  WHERE price_usd > 0\n)\nSELECT\n  username_page, dow, hod,\n  ROUND(price_usd) AS price_q,\n  SUM(sent)        AS sent_sum,\n  SUM(purchased)   AS purchased_sum,\n  SUM(earnings)    AS earnings_sum,\n  SAFE_DIVIDE(SUM(purchased), NULLIF(SUM(sent),0)) AS buy_rate_sent,\n  SAFE_DIVIDE(SUM(earnings),  NULLIF(SUM(sent),0)) AS rps\nFROM ppv\nGROUP BY 1,2,3,4",
    "schema": [
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "dow",
        "type": "INTEGER"
      },
      {
        "name": "hod",
        "type": "INTEGER"
      },
      {
        "name": "price_q",
        "type": "NUMERIC"
      },
      {
        "name": "sent_sum",
        "type": "INTEGER"
      },
      {
        "name": "purchased_sum",
        "type": "INTEGER"
      },
      {
        "name": "earnings_sum",
        "type": "NUMERIC"
      },
      {
        "name": "buy_rate_sent",
        "type": "FLOAT"
      },
      {
        "name": "rps",
        "type": "NUMERIC"
      }
    ]
  },
  {
    "id": "v_ppv_price_reco_lcb_28d_v3",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-06 19:39:52",
    "modified": "2025-09-06 19:39:52",
    "query": "WITH eb AS (\n  SELECT\n    c.username_page, c.dow, c.hod, c.price_q,\n    c.sent_sum AS n, c.purchased_sum AS x,\n    SAFE_DIVIDE(c.purchased_sum + 200 * p.mu_buy_sent,\n                c.sent_sum      + 200) AS p_buy_eb\n  FROM `of-scheduler-proj.mart.v_ppv_price_curve_28d_v3` c\n  JOIN `of-scheduler-proj.mart.v_page_priors_l90_v3` p USING (username_page)\n),\nlcb AS (\n  SELECT\n    e.*,\n    1.6448536269514722 AS z,\n    GREATEST(e.n, 1)   AS n_eff,\n    (\n      (e.p_buy_eb + (POW(1.6448536269514722,2)/(2*GREATEST(e.n,1))) )\n      - 1.6448536269514722 * SQRT(\n          SAFE_DIVIDE(e.p_buy_eb*(1-e.p_buy_eb), GREATEST(e.n,1))\n          + POW(1.6448536269514722,2)/(4*POW(GREATEST(e.n,1),2))\n        )\n    ) / (1 + POW(1.6448536269514722,2)/GREATEST(e.n,1)) AS p_buy_lcb\n  FROM eb e\n),\nscored AS (\n  SELECT\n    username_page, dow, hod, price_q,\n    p_buy_eb,\n    p_buy_lcb,\n    price_q * p_buy_eb  AS rps_eb,\n    price_q * p_buy_lcb AS rps_lcb\n  FROM lcb\n),\nranked AS (\n  SELECT\n    s.*,\n    ROW_NUMBER() OVER (\n      PARTITION BY username_page, dow, hod\n      ORDER BY rps_lcb DESC, price_q\n    ) AS rn\n  FROM scored s\n)\nSELECT * EXCEPT(rn)\nFROM ranked\nWHERE rn = 1",
    "schema": [
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "dow",
        "type": "INTEGER"
      },
      {
        "name": "hod",
        "type": "INTEGER"
      },
      {
        "name": "price_q",
        "type": "NUMERIC"
      },
      {
        "name": "p_buy_eb",
        "type": "FLOAT"
      },
      {
        "name": "p_buy_lcb",
        "type": "FLOAT"
      },
      {
        "name": "rps_eb",
        "type": "FLOAT"
      },
      {
        "name": "rps_lcb",
        "type": "FLOAT"
      }
    ]
  },
  {
    "id": "v_scheduler_kpis_7d_28d",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-13 14:06:43",
    "modified": "2025-09-13 14:06:43",
    "query": "WITH m AS (\n  SELECT username_std, sending_ts, earnings_usd\n  FROM `of-scheduler-proj.layer_04_semantic.message_facts`\n  WHERE sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 28 DAY)\n),\nassign AS (\n  SELECT username_std, assigned_scheduler\n  FROM `of-scheduler-proj.layer_04_semantic.v_page_dim`\n)\nSELECT\n  assign.assigned_scheduler AS scheduler,\n  SUM(IF(m.sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY), m.earnings_usd, 0)) AS rev_7d,\n  SUM(m.earnings_usd) AS rev_28d,\n  COUNTIF(m.sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY)) AS msgs_7d,\n  COUNT(*) AS msgs_28d\nFROM m\nJOIN assign USING (username_std)\nGROUP BY scheduler\nORDER BY rev_28d DESC",
    "schema": [
      {
        "name": "scheduler",
        "type": "STRING"
      },
      {
        "name": "rev_7d",
        "type": "NUMERIC"
      },
      {
        "name": "rev_28d",
        "type": "NUMERIC"
      },
      {
        "name": "msgs_7d",
        "type": "INTEGER"
      },
      {
        "name": "msgs_28d",
        "type": "INTEGER"
      }
    ]
  },
  {
    "id": "v_send_to_perf_link_180d",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-03 01:34:42",
    "modified": "2025-09-03 01:34:42",
    "query": "WITH ss AS (\n  SELECT * FROM `of-scheduler-proj.core.scheduled_send_facts`\n),\nmm AS (\n  SELECT username_std, sending_ts, caption_hash, price_usd, earnings_usd, sent, viewed, purchased, sender\n  FROM `of-scheduler-proj.core.message_facts`\n  WHERE sending_ts >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 180 DAY)\n),\ncl AS (\n  SELECT username_std, caption_id, caption_hash\n  FROM `of-scheduler-proj.core.caption_dim`\n),\ncand AS (\n  SELECT\n    ss.username_std, ss.logged_ts, ss.scheduler_name, ss.caption_id, ss.was_modified,\n    ss.price_usd_scheduled, ss.tracking_hash,\n    mm.sending_ts, mm.caption_hash AS hash_msg,\n    mm.price_usd, mm.earnings_usd, mm.sent, mm.viewed, mm.purchased, mm.sender,\n    CASE\n      WHEN ss.tracking_hash IS NOT NULL AND ss.tracking_hash = mm.caption_hash THEN 3\n      WHEN ss.caption_id IS NOT NULL AND EXISTS (\n        SELECT 1 FROM cl\n        WHERE cl.username_std = ss.username_std\n          AND cl.caption_id   = ss.caption_id\n          AND cl.caption_hash = mm.caption_hash\n      ) THEN 2\n      WHEN ss.price_usd_scheduled IS NOT NULL\n           AND ABS(ss.price_usd_scheduled - mm.price_usd) < 0.01\n           AND mm.sending_ts BETWEEN TIMESTAMP_SUB(ss.logged_ts, INTERVAL 1 DAY)\n                                 AND TIMESTAMP_ADD(ss.logged_ts, INTERVAL 14 DAY) THEN 1\n      ELSE 0\n    END AS match_score,\n    ABS(TIMESTAMP_DIFF(mm.sending_ts, ss.logged_ts, MINUTE)) AS dt_min\n  FROM ss\n  JOIN mm USING (username_std)\n  WHERE (ss.tracking_hash IS NOT NULL AND ss.tracking_hash = mm.caption_hash)\n     OR (ss.caption_id IS NOT NULL AND EXISTS (\n           SELECT 1 FROM cl\n           WHERE cl.username_std = ss.username_std\n             AND cl.caption_id   = ss.caption_id\n             AND cl.caption_hash = mm.caption_hash))\n     OR (ss.price_usd_scheduled IS NOT NULL\n         AND ABS(ss.price_usd_scheduled - mm.price_usd) < 0.01\n         AND mm.sending_ts BETWEEN TIMESTAMP_SUB(ss.logged_ts, INTERVAL 1 DAY)\n                               AND TIMESTAMP_ADD(ss.logged_ts, INTERVAL 14 DAY))\n)\nSELECT\n  username_std,\n  DATE(sending_ts) AS sent_date,\n  scheduler_name,\n  sender,\n  logged_ts,\n  caption_id,\n  was_modified,\n  price_usd_scheduled,\n  sending_ts,\n  hash_msg,\n  price_usd,\n  earnings_usd,\n  sent,\n  viewed,\n  purchased,\n  CASE match_score WHEN 3 THEN 'hash' WHEN 2 THEN 'caption_id' ELSE 'time_price' END AS matched_by\nFROM cand\nQUALIFY ROW_NUMBER() OVER (\n  PARTITION BY username_std, logged_ts, caption_id\n  ORDER BY match_score DESC, dt_min ASC\n) = 1",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "sent_date",
        "type": "DATE"
      },
      {
        "name": "scheduler_name",
        "type": "STRING"
      },
      {
        "name": "sender",
        "type": "STRING"
      },
      {
        "name": "logged_ts",
        "type": "TIMESTAMP"
      },
      {
        "name": "caption_id",
        "type": "STRING"
      },
      {
        "name": "was_modified",
        "type": "BOOLEAN"
      },
      {
        "name": "price_usd_scheduled",
        "type": "NUMERIC"
      },
      {
        "name": "sending_ts",
        "type": "TIMESTAMP"
      },
      {
        "name": "hash_msg",
        "type": "STRING"
      },
      {
        "name": "price_usd",
        "type": "NUMERIC"
      },
      {
        "name": "earnings_usd",
        "type": "NUMERIC"
      },
      {
        "name": "sent",
        "type": "INTEGER"
      },
      {
        "name": "viewed",
        "type": "INTEGER"
      },
      {
        "name": "purchased",
        "type": "INTEGER"
      },
      {
        "name": "matched_by",
        "type": "STRING"
      }
    ]
  },
  {
    "id": "v_slot_momentum_v3",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-06 19:43:53",
    "modified": "2025-09-06 19:43:53",
    "query": "WITH a7 AS (\n  SELECT username_page, dow, hod, AVG(rps) AS rps_l7\n  FROM `of-scheduler-proj.mart.fn_dm_send_facts`(7)\n  GROUP BY 1,2,3\n),\na28 AS (\n  SELECT username_page, dow, hod, AVG(rps) AS rps_l28\n  FROM `of-scheduler-proj.mart.fn_dm_send_facts`(28)\n  GROUP BY 1,2,3\n)\nSELECT\n  COALESCE(a28.username_page, a7.username_page) AS username_page,\n  COALESCE(a28.dow, a7.dow) AS dow,\n  COALESCE(a28.hod, a7.hod) AS hod,\n  a7.rps_l7,\n  a28.rps_l28,\n  SAFE_DIVIDE(a7.rps_l7, NULLIF(a28.rps_l28, 0)) - 1 AS momentum_lift\nFROM a7\nFULL OUTER JOIN a28\nUSING (username_page, dow, hod)",
    "schema": [
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "dow",
        "type": "INTEGER"
      },
      {
        "name": "hod",
        "type": "INTEGER"
      },
      {
        "name": "rps_l7",
        "type": "NUMERIC"
      },
      {
        "name": "rps_l28",
        "type": "NUMERIC"
      },
      {
        "name": "momentum_lift",
        "type": "NUMERIC"
      }
    ]
  },
  {
    "id": "v_slot_recommendations_next24_gated_v1",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-07 14:05:16",
    "modified": "2025-09-07 14:05:16",
    "query": "WITH base AS (\n  SELECT username_page, slot_dt_local\n  FROM `of-scheduler-proj.mart.v_slot_recommendations_next24_v3`\n),\ndh AS (\n  SELECT\n    b.username_page,\n    b.slot_dt_local,\n    MOD(EXTRACT(DAYOFWEEK FROM b.slot_dt_local) + 5, 7) AS dow,\n    CAST(FORMAT_DATETIME('%H', b.slot_dt_local) AS INT64) AS hod\n  FROM base b\n),\nprice AS (\n  SELECT s.username_page, s.dow, s.hod, p.price_q AS reco_price_usd\n  FROM `of-scheduler-proj.mart.v_slot_scorecard_v3` s\n  LEFT JOIN `of-scheduler-proj.mart.v_ppv_price_reco_lcb_28d_v3` p\n    ON p.username_page = s.username_page\n   AND p.dow = s.dow\n   AND p.hod = s.hod\n),\npaid AS (\n  SELECT username_page, is_paid\n  FROM `of-scheduler-proj.core.v_page_paid_final_v1`\n)\nSELECT\n  dh.username_page,\n  dh.slot_dt_local,\n  dh.dow, dh.hod,\n  CASE WHEN pr.reco_price_usd > 0 THEN 'ppv' ELSE 'free' END AS reco_dm_type,\n  IFNULL(pr.reco_price_usd, 0) AS reco_price_usd\nFROM dh\nLEFT JOIN price pr USING (username_page, dow, hod)\nLEFT JOIN paid  p  USING (username_page)\nWHERE NOT (p.is_paid = FALSE AND pr.reco_price_usd > 0)",
    "schema": [
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "slot_dt_local",
        "type": "DATETIME"
      },
      {
        "name": "dow",
        "type": "INTEGER"
      },
      {
        "name": "hod",
        "type": "INTEGER"
      },
      {
        "name": "reco_dm_type",
        "type": "STRING"
      },
      {
        "name": "reco_price_usd",
        "type": "NUMERIC"
      }
    ]
  },
  {
    "id": "v_slot_recommendations_next24_v3",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-13 12:24:16",
    "modified": "2025-09-13 12:24:16",
    "query": "WITH pages AS (\n  SELECT v.username_page, v.username_std, COALESCE(pd.tz,'UTC') AS tz\n  FROM `of-scheduler-proj.layer_04_semantic.v_pages` v\n  LEFT JOIN `of-scheduler-proj.layer_04_semantic.v_page_dim` pd USING (username_std)\n),\nnowz AS (\n  SELECT username_page, username_std, tz, DATETIME(CURRENT_TIMESTAMP(), tz) AS now_local\n  FROM pages\n),\ngrid AS (\n  SELECT n.username_page, n.username_std, n.tz,\n         DATETIME_TRUNC(n.now_local, HOUR) + INTERVAL h HOUR AS slot_dt_local\n  FROM nowz n, UNNEST(GENERATE_ARRAY(0,23)) AS h\n),\nfeat AS (\n  SELECT\n    g.username_page, g.username_std, g.tz,\n    MOD(EXTRACT(DAYOFWEEK FROM g.slot_dt_local) + 5, 7) AS dow,\n    CAST(FORMAT_DATETIME('%H', g.slot_dt_local) AS INT64) AS hod,\n    g.slot_dt_local\n  FROM grid g\n),\nbest_price AS (\n  SELECT s.username_page, s.dow, s.hod, s.slot_score_base,\n         p.price_q AS best_ppv_price,\n         p.p_buy_eb, p.rps_eb, p.rps_lcb\n  FROM `of-scheduler-proj.mart.v_slot_scorecard_v3` s\n  LEFT JOIN `of-scheduler-proj.mart.v_ppv_price_reco_lcb_28d_v3` p\n    ON p.username_page=s.username_page AND p.dow=s.dow AND p.hod=s.hod\n),\nquota AS (\n  SELECT username_std, dow, ppv_quota AS max_sends_today\n  FROM `of-scheduler-proj.mart.v_daily_quota_policy_v3`\n)\nSELECT\n  f.username_page,\n  f.slot_dt_local,\n  f.dow, f.hod,\n  b.slot_score_base,\n  b.p_buy_eb  AS best_ppv_buy_rate,\n  b.rps_eb,\n  b.rps_lcb,\n  -- paid/free gate\n  CASE\n    WHEN NOT COALESCE(pp.is_paid_sub, FALSE) THEN 'free'\n    WHEN b.rps_lcb IS NOT NULL AND b.rps_lcb >= COALESCE(sc.rps_free,0) THEN 'ppv'\n    ELSE 'free'\n  END AS reco_dm_type,\n  CASE\n    WHEN NOT COALESCE(pp.is_paid_sub, FALSE) THEN 0\n    WHEN b.rps_lcb IS NOT NULL AND b.rps_lcb >= COALESCE(sc.rps_free,0) THEN IFNULL(b.best_ppv_price,0)\n    ELSE 0\n  END AS reco_price_usd\nFROM feat f\nLEFT JOIN best_price b USING (username_page, dow, hod)\nLEFT JOIN `of-scheduler-proj.mart.v_slot_scorecard_v3` sc USING (username_page, dow, hod)\nLEFT JOIN quota q\n  ON q.username_std=f.username_std AND q.dow=f.dow\nLEFT JOIN `of-scheduler-proj.layer_04_semantic.v_page_paid_status` pp\n  ON pp.username_std = f.username_std\nQUALIFY ROW_NUMBER() OVER (\n  PARTITION BY f.username_page, DATE(f.slot_dt_local)\n  ORDER BY b.slot_score_base DESC, f.slot_dt_local\n) <= COALESCE(q.max_sends_today, 4)",
    "schema": [
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "slot_dt_local",
        "type": "DATETIME"
      },
      {
        "name": "dow",
        "type": "INTEGER"
      },
      {
        "name": "hod",
        "type": "INTEGER"
      },
      {
        "name": "slot_score_base",
        "type": "FLOAT"
      },
      {
        "name": "best_ppv_buy_rate",
        "type": "FLOAT"
      },
      {
        "name": "rps_eb",
        "type": "FLOAT"
      },
      {
        "name": "rps_lcb",
        "type": "FLOAT"
      },
      {
        "name": "reco_dm_type",
        "type": "STRING"
      },
      {
        "name": "reco_price_usd",
        "type": "NUMERIC"
      }
    ]
  },
  {
    "id": "v_slot_scorecard_v3",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-06 19:51:09",
    "modified": "2025-09-06 19:51:09",
    "query": "WITH base AS (\n  SELECT\n    username_page, dow, hod,\n    MAX(IF(price_band='p3',  rps_eb, NULL)) AS rps_p3,\n    MAX(IF(price_band='p2',  rps_eb, NULL)) AS rps_p2,\n    MAX(IF(price_band='p1',  rps_eb, NULL)) AS rps_p1,\n    MAX(IF(price_band='free',rps_eb, NULL)) AS rps_free\n  FROM `of-scheduler-proj.mart.v_dm_slot_eb_28d_v3`\n  GROUP BY 1,2,3\n)\nSELECT\n  b.username_page, b.dow, b.hod,\n  b.rps_p3, b.rps_p2, b.rps_p1, b.rps_free,\n  COALESCE(m.momentum_lift, 0) AS momentum_lift,\n  GREATEST(\n    COALESCE(b.rps_p3,0), COALESCE(b.rps_p2,0),\n    COALESCE(b.rps_p1,0), COALESCE(b.rps_free,0)\n  ) AS rps_base,\n  -- momentum scaled by RPS; clamp lift to [-1, 1] using GREATEST/LEAST\n  GREATEST(\n    COALESCE(b.rps_p3,0), COALESCE(b.rps_p2,0),\n    COALESCE(b.rps_p1,0), COALESCE(b.rps_free,0)\n  ) * (1 + 0.25 * GREATEST(-1.0, LEAST(1.0, COALESCE(m.momentum_lift,0)))) AS slot_score_base\nFROM base b\nLEFT JOIN `of-scheduler-proj.mart.v_slot_momentum_v3` m\n  USING (username_page, dow, hod)",
    "schema": [
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "dow",
        "type": "INTEGER"
      },
      {
        "name": "hod",
        "type": "INTEGER"
      },
      {
        "name": "rps_p3",
        "type": "FLOAT"
      },
      {
        "name": "rps_p2",
        "type": "FLOAT"
      },
      {
        "name": "rps_p1",
        "type": "FLOAT"
      },
      {
        "name": "rps_free",
        "type": "FLOAT"
      },
      {
        "name": "momentum_lift",
        "type": "NUMERIC"
      },
      {
        "name": "rps_base",
        "type": "FLOAT"
      },
      {
        "name": "slot_score_base",
        "type": "FLOAT"
      }
    ]
  },
  {
    "id": "v_weekly_feasibility_alerts",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-13 14:06:56",
    "modified": "2025-09-13 14:06:56",
    "query": "WITH days_to_check AS (           -- the page-days we actually plan\n  SELECT DISTINCT username_std, date_local\n  FROM `of-scheduler-proj.mart.weekly_template_7d_latest`\n),\n\n-- clamp + swap windows once, using the same rules as the planner\npd0 AS (\n  SELECT\n    username_std,\n    CASE WHEN min_hod IS NULL AND max_hod IS NULL THEN 0\n         WHEN min_hod IS NULL THEN 0\n         ELSE GREATEST(0, LEAST(23, CAST(min_hod AS INT64))) END AS min0,\n    CASE WHEN min_hod IS NULL AND max_hod IS NULL THEN 23\n         WHEN max_hod IS NULL THEN 23\n         ELSE GREATEST(0, LEAST(23, CAST(max_hod AS INT64))) END AS max0\n  FROM `of-scheduler-proj.layer_04_semantic.v_page_dim`\n  WHERE COALESCE(LOWER(CAST(is_active AS STRING)) IN ('true','t','1','yes','y'), TRUE)\n),\npd AS (\n  SELECT\n    username_std,\n    CASE WHEN min0 IS NOT NULL AND max0 IS NOT NULL AND min0 > max0 THEN max0 ELSE min0 END AS min_hod_eff,\n    CASE WHEN min0 IS NOT NULL AND max0 IS NOT NULL AND min0 > max0 THEN min0 ELSE max0 END AS max_hod_eff\n  FROM pd0\n),\n\n-- policy quota by DOW (0=Mon..6=Sun like the planner)\npolicy AS (\n  SELECT username_std, dow, ppv_quota\n  FROM `of-scheduler-proj.mart.v_daily_quota_policy_v3`\n),\n\nbase AS (\n  SELECT\n    d.username_std,\n    d.date_local,\n    p.min_hod_eff AS min_h,\n    p.max_hod_eff AS max_h,\n    q.ppv_quota   AS quota,\n    MOD(EXTRACT(DAYOFWEEK FROM d.date_local) + 5, 7) AS dow\n  FROM days_to_check d\n  JOIN pd p USING (username_std)\n  LEFT JOIN policy q\n    ON q.username_std = d.username_std\n   AND q.dow         = MOD(EXTRACT(DAYOFWEEK FROM d.date_local) + 5, 7)\n),\n\ncalc AS (\n  SELECT\n    username_std,\n    date_local,\n    dow,\n    quota,\n    min_h,\n    max_h,\n    (max_h - min_h) AS window_width,\n    GREATEST(0, 2 * (COALESCE(quota, 0) - 1)) AS width_needed_2h\n  FROM base\n)\n\nSELECT *\nFROM calc\nWHERE quota IS NOT NULL\n  AND window_width < width_needed_2h   -- impossible to satisfy â‰¥2h with this quota/window\nORDER BY username_std, date_local",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "date_local",
        "type": "DATE"
      },
      {
        "name": "dow",
        "type": "INTEGER"
      },
      {
        "name": "quota",
        "type": "INTEGER"
      },
      {
        "name": "min_h",
        "type": "INTEGER"
      },
      {
        "name": "max_h",
        "type": "INTEGER"
      },
      {
        "name": "window_width",
        "type": "INTEGER"
      },
      {
        "name": "width_needed_2h",
        "type": "INTEGER"
      }
    ]
  },
  {
    "id": "v_weekly_template_7d_pages",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-13 14:07:02",
    "modified": "2025-09-13 14:07:02",
    "query": "WITH base AS (\n  SELECT * FROM `of-scheduler-proj.mart.weekly_template_7d_latest`\n),\ntypes AS (\n  SELECT username_std, page_type FROM `of-scheduler-proj.layer_04_semantic.v_pages`\n),\nassign AS (\n  SELECT username_std, ANY_VALUE(assigned_scheduler) AS assigned_scheduler\n  FROM `of-scheduler-proj.layer_04_semantic.v_page_dim`\n  WHERE COALESCE(is_active, TRUE)\n  GROUP BY username_std\n)\nSELECT\n  b.username_std,\n  t.page_type,\n  CONCAT(b.username_std,'__',t.page_type) AS username_page,\n  COALESCE(a.assigned_scheduler, b.scheduler_name, 'unassigned') AS scheduler_name,\n  b.tz, b.date_local, b.slot_rank, b.hod_local, b.price_usd,\n  b.planned_local_datetime, b.scheduled_datetime_utc,\n  TO_BASE64(SHA256(CONCAT(\n    b.username_std,'__',t.page_type,'|',CAST(b.date_local AS STRING),'|',CAST(b.hod_local AS STRING)\n  ))) AS tracking_hash\nFROM base b\nJOIN types t USING (username_std)\nLEFT JOIN assign a USING (username_std)",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "page_type",
        "type": "STRING"
      },
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "scheduler_name",
        "type": "STRING"
      },
      {
        "name": "tz",
        "type": "STRING"
      },
      {
        "name": "date_local",
        "type": "DATE"
      },
      {
        "name": "slot_rank",
        "type": "INTEGER"
      },
      {
        "name": "hod_local",
        "type": "INTEGER"
      },
      {
        "name": "price_usd",
        "type": "NUMERIC"
      },
      {
        "name": "planned_local_datetime",
        "type": "DATETIME"
      },
      {
        "name": "scheduled_datetime_utc",
        "type": "TIMESTAMP"
      },
      {
        "name": "tracking_hash",
        "type": "STRING"
      }
    ]
  },
  {
    "id": "v_weekly_template_7d_pages_final",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-13 22:21:22",
    "modified": "2025-09-13 22:21:22",
    "query": "SELECT *\nFROM `of-scheduler-proj.mart.v_weekly_template_7d_pages`",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "page_type",
        "type": "STRING"
      },
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "scheduler_name",
        "type": "STRING"
      },
      {
        "name": "tz",
        "type": "STRING"
      },
      {
        "name": "date_local",
        "type": "DATE"
      },
      {
        "name": "slot_rank",
        "type": "INTEGER"
      },
      {
        "name": "hod_local",
        "type": "INTEGER"
      },
      {
        "name": "price_usd",
        "type": "NUMERIC"
      },
      {
        "name": "planned_local_datetime",
        "type": "DATETIME"
      },
      {
        "name": "scheduled_datetime_utc",
        "type": "TIMESTAMP"
      },
      {
        "name": "tracking_hash",
        "type": "STRING"
      }
    ]
  },
  {
    "id": "v_weekly_template_7d_pages_overrides",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-10 03:53:53",
    "modified": "2025-09-10 03:53:53",
    "query": "WITH base AS (\n  SELECT\n    b.username_std, b.page_type, b.username_page, b.scheduler_name,\n    b.tz, b.date_local, b.slot_rank, b.hod_local, b.price_usd,\n    b.planned_local_datetime, b.scheduled_datetime_utc, b.tracking_hash\n  FROM `of-scheduler-proj.mart.v_weekly_template_7d_pages` b\n),\nr AS (\n  SELECT alias_norm, resolved_username_std\n  FROM `of-scheduler-proj.core.v_username_resolver`\n)\nSELECT\n  COALESCE(r.resolved_username_std, base.username_std) AS username_std,\n  base.page_type,\n  CONCAT(COALESCE(r.resolved_username_std, base.username_std), '__', base.page_type) AS username_page,\n  COALESCE(o.assigned_scheduler, base.scheduler_name, 'unassigned') AS scheduler_name,\n  base.tz, base.date_local, base.slot_rank, base.hod_local, base.price_usd,\n  base.planned_local_datetime, base.scheduled_datetime_utc, base.tracking_hash\nFROM base\nLEFT JOIN r\n  ON r.alias_norm = `of-scheduler-proj.util.norm_username`(base.username_std)\nLEFT JOIN `of-scheduler-proj.core.page_scheduler_overrides` o\n  ON o.username_std = COALESCE(r.resolved_username_std, base.username_std)",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "page_type",
        "type": "STRING"
      },
      {
        "name": "username_page",
        "type": "STRING"
      },
      {
        "name": "scheduler_name",
        "type": "STRING"
      },
      {
        "name": "tz",
        "type": "STRING"
      },
      {
        "name": "date_local",
        "type": "DATE"
      },
      {
        "name": "slot_rank",
        "type": "INTEGER"
      },
      {
        "name": "hod_local",
        "type": "INTEGER"
      },
      {
        "name": "price_usd",
        "type": "NUMERIC"
      },
      {
        "name": "planned_local_datetime",
        "type": "DATETIME"
      },
      {
        "name": "scheduled_datetime_utc",
        "type": "TIMESTAMP"
      },
      {
        "name": "tracking_hash",
        "type": "STRING"
      }
    ]
  },
  {
    "id": "v_weekly_template_7d_v7",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-03 21:24:43",
    "modified": "2025-09-03 21:24:43",
    "query": "WITH quota AS (\n  SELECT username_std, assigned_scheduler, tz, dow, ppv_quota, hour_pool, is_burst_dow\n  FROM `of-scheduler-proj.mart.v_daily_quota_policy_v3`\n),\npd0 AS (\n  SELECT\n    username_std,\n    CASE WHEN min_hod IS NULL AND max_hod IS NULL THEN NULL\n         WHEN min_hod IS NULL THEN 0\n         ELSE GREATEST(0, LEAST(23, CAST(min_hod AS INT64))) END AS min0,\n    CASE WHEN min_hod IS NULL AND max_hod IS NULL THEN NULL\n         WHEN max_hod IS NULL THEN 23\n         ELSE GREATEST(0, LEAST(23, CAST(max_hod AS INT64))) END AS max0\n  FROM `of-scheduler-proj.core.page_dim`\n  WHERE COALESCE(LOWER(CAST(is_active AS STRING)) IN ('true','t','1','yes','y'), TRUE)\n),\npd AS (\n  SELECT\n    username_std,\n    CASE WHEN min0 IS NOT NULL AND max0 IS NOT NULL AND min0 > max0 THEN max0 ELSE min0 END AS min_hod_eff,\n    CASE WHEN min0 IS NOT NULL AND max0 IS NOT NULL AND min0 > max0 THEN min0 ELSE max0 END AS max_hod_eff\n  FROM pd0\n),\nweights AS (\n  SELECT username_std,\n         COALESCE(weight_price,     1.00) AS w_price,\n         COALESCE(exploration_rate, 0.15) AS explore_rate\n  FROM `of-scheduler-proj.core.page_personalization_weights`\n),\nstate AS (\n  SELECT username_std, COALESCE(page_state,'balance') AS page_state\n  FROM `of-scheduler-proj.core.page_state`\n),\ndow_hod AS (  -- weekdayÃ—hour perf\n  SELECT username_std, dow_local AS dow, hod_local AS hod, score\n  FROM `of-scheduler-proj.mart.v_mm_dow_hod_180d_local_v2`\n),\ndow_pref AS (  -- pre-agg\n  SELECT username_std, dow, hod, SUM(score) AS s\n  FROM dow_hod\n  GROUP BY username_std, dow, hod\n),\nbest_global AS (  -- global fallback\n  SELECT username_std, hod_local AS hod, SUM(score) AS s_g\n  FROM `of-scheduler-proj.mart.v_mm_dow_hod_180d_local_v2`\n  GROUP BY username_std, hod_local\n),\nprice_prof AS (\n  SELECT username_std, p35, p50, p60, p80, p90, price_mode\n  FROM `of-scheduler-proj.mart.v_mm_price_profile_90d_v2`\n),\ndefaults AS ( SELECT ARRAY<INT64>[21,20,18,15,12,22,19,16,13,10,23,14,17,9,8,11] AS default_hours ),\n\n/* ---------- 7 calendar days per page ---------- */\ndays AS (\n  SELECT\n    q.username_std, q.assigned_scheduler, q.tz,\n    p.min_hod_eff, p.max_hod_eff,\n    DATE_ADD(CURRENT_DATE(q.tz), INTERVAL d DAY) AS date_local,\n    MOD(EXTRACT(DAYOFWEEK FROM DATE_ADD(CURRENT_DATE(q.tz), INTERVAL d DAY)) + 5, 7) AS dow_local,\n    q.ppv_quota AS quota, q.hour_pool AS hour_pool, q.is_burst_dow,\n    ABS(FARM_FINGERPRINT(CONCAT(q.username_std, CAST(DATE_ADD(CURRENT_DATE(q.tz), INTERVAL d DAY) AS STRING)))) AS seed_day\n  FROM quota q\n  JOIN pd p USING (username_std)\n  CROSS JOIN UNNEST(GENERATE_ARRAY(0,6)) AS d\n  WHERE MOD(EXTRACT(DAYOFWEEK FROM DATE_ADD(CURRENT_DATE(q.tz), INTERVAL d DAY)) + 5, 7) = q.dow\n    AND q.ppv_quota > 0\n),\n\n/* ---------- Candidate hours via JOINs ---------- */\ncand_union AS (\n  -- DOW-specific\n  SELECT d.*, dp.hod AS h, dp.s AS s, 1 AS src\n  FROM days d\n  JOIN dow_pref dp\n    ON dp.username_std = d.username_std\n   AND dp.dow         = d.dow_local\n  UNION ALL\n  -- global fallback\n  SELECT d.*, g.hod AS h, g.s_g AS s, 2 AS src\n  FROM days d\n  JOIN best_global g\n    ON g.username_std = d.username_std\n  UNION ALL\n  -- default last resort\n  SELECT d.*, h AS h, 0 AS s, 3 AS src\n  FROM days d\n  CROSS JOIN UNNEST((SELECT default_hours FROM defaults)) AS h\n),\ncand_filtered AS (\n  SELECT * FROM cand_union\n  WHERE h BETWEEN COALESCE(min_hod_eff,0) AND COALESCE(max_hod_eff,23)\n),\ncand_dedup AS (\n  SELECT *,\n         ROW_NUMBER() OVER (\n           PARTITION BY username_std, date_local, h\n           ORDER BY src, s DESC, h\n         ) AS rn_h\n  FROM cand_filtered\n),\ncand_ranked AS ( SELECT * FROM cand_dedup WHERE rn_h = 1 ),\npool AS (\n  SELECT\n    username_std, assigned_scheduler, tz, date_local, dow_local,\n    quota, hour_pool, is_burst_dow, seed_day,\n    COALESCE(min_hod_eff,0)  AS min_h,\n    COALESCE(max_hod_eff,23) AS max_h,\n    ARRAY_AGG(h ORDER BY src, s DESC, h LIMIT 24) AS hours_ranked\n  FROM cand_ranked\n  GROUP BY username_std, assigned_scheduler, tz, date_local, dow_local,\n           quota, hour_pool, is_burst_dow, seed_day, min_hod_eff, max_hod_eff\n),\n\n/* ---------- Segment + anchors ---------- */\nsegments AS (\n  SELECT\n    p.*,\n    IF(ARRAY_LENGTH(p.hours_ranked) > 0, p.hours_ranked[OFFSET(0)],                               COALESCE(p.min_h, 9))  AS span_start,\n    IF(ARRAY_LENGTH(p.hours_ranked) > 0, p.hours_ranked[OFFSET(ARRAY_LENGTH(p.hours_ranked)-1)], COALESCE(p.max_h, 21)) AS span_end\n  FROM pool p\n),\nanchors AS (\n  SELECT\n    s.username_std, s.assigned_scheduler, s.tz, s.date_local, s.dow_local,\n    s.quota, s.hour_pool, s.is_burst_dow, s.seed_day,\n    s.hours_ranked, s.min_h, s.max_h,\n    LEAST(s.max_h, GREATEST(s.min_h, s.span_start)) AS a_start,\n    GREATEST(s.min_h, LEAST(s.max_h, s.span_end))   AS a_end\n  FROM segments s\n),\nanchor_grid AS (\n  SELECT\n    a.*,\n    (a.a_end - a.a_start) AS span_len,\n    LEAST(6, GREATEST(2,\n      CAST(ROUND(SAFE_DIVIDE(GREATEST(a.a_end - a.a_start, 2), GREATEST(a.quota-1, 1))) AS INT64)\n    )) AS seg_w\n  FROM anchors a\n),\nanchor_rows AS (\n  SELECT\n    g.username_std, g.assigned_scheduler, g.tz, g.date_local, g.dow_local,\n    g.hour_pool, g.is_burst_dow, g.seed_day, g.hours_ranked,\n    g.min_h, g.max_h, g.span_len, g.seg_w, g.quota,\n    pos AS slot_rank,\n    CAST(ROUND(g.a_start + pos * g.seg_w + MOD(g.seed_day + pos, 3) - 1) AS INT64) AS anchor_h,\n    CASE WHEN g.quota = 1 THEN CAST(ROUND((g.a_start + g.a_end)/2.0) AS INT64) ELSE NULL END AS anchor_h_center\n  FROM anchor_grid g\n  CROSS JOIN UNNEST(GENERATE_ARRAY(0, LEAST(g.quota-1, 9))) AS pos\n),\n\n/* ---------- Pick nearest candidate hour (effective pool avoids collisions) ---------- */\nnearest_pick AS (\n  SELECT\n    r.* EXCEPT(hours_ranked),\n    cand AS hod_cand,\n    off  AS cand_rank,\n    ROW_NUMBER() OVER (\n      PARTITION BY r.username_std, r.date_local, r.slot_rank\n      ORDER BY ABS(cand - COALESCE(r.anchor_h_center, r.anchor_h)), off, cand\n    ) AS rn\n  FROM anchor_rows r\n  CROSS JOIN UNNEST(r.hours_ranked) AS cand WITH OFFSET off\n  WHERE cand BETWEEN r.min_h AND r.max_h\n    AND off < GREATEST(r.hour_pool, LEAST(ARRAY_LENGTH(r.hours_ranked), r.quota * 3))\n),\npicked0 AS (\n  SELECT\n    username_std, assigned_scheduler, tz, date_local, dow_local,\n    slot_rank, is_burst_dow, seed_day,\n    hod_cand AS hod_local\n  FROM nearest_pick\n  WHERE rn = 1\n),\n\n/* ---------- Closed-form spacing: enforce â‰¥2h and â‰¤6h inside [min_h, max_h] ---------- */\nday_bounds AS (\n  SELECT username_std, date_local, MIN(min_h) AS min_h, MAX(max_h) AS max_h\n  FROM pool\n  GROUP BY username_std, date_local\n),\nordered AS (\n  SELECT\n    p.*,\n    ROW_NUMBER() OVER (PARTITION BY p.username_std, p.date_local ORDER BY p.hod_local) AS idx,\n    COUNT(*)    OVER (PARTITION BY p.username_std, p.date_local)                         AS n_slots\n  FROM picked0 p\n),\nwith_bounds AS (\n  SELECT o.*, b.min_h, b.max_h\n  FROM ordered o\n  JOIN day_bounds b USING (username_std, date_local)\n),\nlower_env AS (  -- ensure â‰¥2h and start bound\n  SELECT\n    *,\n    -- closed-form lower envelope: 2*idx + prefix_max(hod_local - 2*idx)\n    (2*idx\n      + MAX(hod_local - 2*idx) OVER (\n          PARTITION BY username_std, date_local\n          ORDER BY idx\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        )\n    )                                                          AS env2,\n    -- minimal feasible hour for idx given min_h and â‰¥2h\n    (min_h + 2*(idx-1))                                       AS start2\n  FROM with_bounds\n),\ny AS (\n  SELECT\n    *,\n    GREATEST(hod_local, env2, start2) AS y_lower  -- apply the â‰¥2h lower envelope\n  FROM lower_env\n),\nupper_env AS (  -- cap by â‰¤6h and room to finish by max_h\n  SELECT\n    *,\n    -- â‰¤6h forward cap in closed form: 6*idx + prefix_min(y_lower - 6*idx)\n    (6*idx\n      + MIN(y_lower - 6*idx) OVER (\n          PARTITION BY username_std, date_local\n          ORDER BY idx\n          ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        )\n    )                                                         AS cap6,\n    -- leave room for remaining slots with â‰¥2h up to max_h\n    (max_h - 2*(n_slots - idx))                               AS cap2_end\n  FROM y\n),\nspaced AS (\n  SELECT\n    username_std, assigned_scheduler, tz, date_local, dow_local,\n    slot_rank, is_burst_dow, seed_day,\n    -- final hour: inside all caps and window\n    CAST(\n      LEAST(\n        GREATEST(y_lower, min_h),      -- not below lower bound/window\n        cap6,                          -- â‰¤6h\n        cap2_end,                      -- room to finish with â‰¥2h\n        max_h                          -- window top\n      ) AS INT64\n    ) AS hod_final\n  FROM upper_env\n),\n\n/* ---------- Price ladder ---------- */\nladder AS (\n  SELECT\n    s.username_std, s.assigned_scheduler, s.tz, s.date_local, s.dow_local,\n    s.slot_rank, s.hod_final AS hod_local, s.is_burst_dow,\n    pp.p35, pp.p50, pp.p60, pp.p80, pp.p90,\n    COALESCE(st.page_state,'balance') AS page_state,\n    COALESCE(w.w_price, 1.00) AS w_price,\n    CASE\n      WHEN COALESCE(w.w_price, 1.00) >= 1.10 THEN 'premium'\n      WHEN COALESCE(w.w_price, 1.00) <= 0.95 THEN 'value'\n      ELSE COALESCE(pp.price_mode,'balanced')\n    END AS price_mode_eff\n  FROM spaced s\n  LEFT JOIN price_prof pp USING (username_std)\n  LEFT JOIN state      st USING (username_std)\n  LEFT JOIN weights    w  USING (username_std)\n),\npriced_base AS (\n  SELECT\n    l.*,\n    CAST(\n      CASE\n        WHEN l.price_mode_eff = 'premium' OR l.is_burst_dow = 1 THEN\n          CASE l.page_state\n            WHEN 'grow'   THEN COALESCE(l.p60,l.p50,l.p35,6)\n            WHEN 'retain' THEN COALESCE(l.p80,l.p60,l.p50,8)\n            ELSE               COALESCE(l.p90,l.p80,l.p60,9)\n          END\n        WHEN l.price_mode_eff = 'value' THEN\n          CASE l.page_state\n            WHEN 'grow'   THEN COALESCE(l.p35,l.p50,5)\n            WHEN 'retain' THEN coalesce(l.p50,l.p60,6)\n            ELSE               COALESCE(l.p60,l.p50,7)\n          END\n        ELSE\n          CASE l.page_state\n            WHEN 'grow'   THEN COALESCE(l.p50,l.p35,5)\n            WHEN 'retain' THEN COALESCE(l.p60,l.p50,6)\n            ELSE               COALESCE(l.p80,l.p60,8)\n          END\n      END AS FLOAT64\n    ) AS price1\n  FROM ladder l\n),\nb1 AS ( SELECT *, price1 + (ROW_NUMBER() OVER (PARTITION BY username_std, date_local, CAST(price1 AS INT64) ORDER BY slot_rank) - 1) AS price2 FROM priced_base ),\nb2 AS ( SELECT *, price2 + (ROW_NUMBER() OVER (PARTITION BY username_std, date_local, CAST(price2 AS INT64) ORDER BY slot_rank) - 1) AS price3 FROM b1 ),\nb3 AS ( SELECT *, price3 + (ROW_NUMBER() OVER (PARTITION BY username_std, date_local, CAST(price3 AS INT64) ORDER BY slot_rank) - 1) AS price4 FROM b2 )\nSELECT\n  username_std,\n  assigned_scheduler AS scheduler_name,\n  tz,\n  date_local,\n  slot_rank,\n  CAST(LEAST(23, GREATEST(0, hod_local)) AS INT64) AS hod_local,\n  CAST(price4 AS FLOAT64) AS price_usd,\n  DATETIME(date_local, TIME(CAST(LEAST(23, GREATEST(0, hod_local)) AS INT64),0,0)) AS planned_local_datetime,\n  TIMESTAMP(DATETIME(date_local, TIME(CAST(LEAST(23, GREATEST(0, hod_local)) AS INT64),0,0)), tz) AS scheduled_datetime_utc\nFROM b3\nORDER BY username_std, date_local, slot_rank",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "scheduler_name",
        "type": "STRING"
      },
      {
        "name": "tz",
        "type": "STRING"
      },
      {
        "name": "date_local",
        "type": "DATE"
      },
      {
        "name": "slot_rank",
        "type": "INTEGER"
      },
      {
        "name": "hod_local",
        "type": "INTEGER"
      },
      {
        "name": "price_usd",
        "type": "FLOAT"
      },
      {
        "name": "planned_local_datetime",
        "type": "DATETIME"
      },
      {
        "name": "scheduled_datetime_utc",
        "type": "TIMESTAMP"
      }
    ]
  },
  {
    "id": "v_weekly_template_audit",
    "type": "VIEW",
    "description": "",
    "created": "2025-09-03 21:28:26",
    "modified": "2025-09-03 21:28:26",
    "query": "WITH q AS (\n  SELECT * FROM `of-scheduler-proj.mart.v_daily_quota_policy_v3`\n),\nw AS (\n  SELECT username_std, weight_volume, weight_price, weight_hours, exploration_rate, updated_at\n  FROM `of-scheduler-proj.core.page_personalization_weights`\n),\ndow AS (  -- total DOW score for context\n  SELECT username_std, dow_local AS dow, SUM(score) AS dow_score\n  FROM `of-scheduler-proj.mart.v_mm_dow_hod_180d_local_v2`\n  GROUP BY username_std, dow_local\n),\npp AS (\n  SELECT username_std, p35, p50, p60, p80, p90, price_mode, corr_price_rev\n  FROM `of-scheduler-proj.mart.v_mm_price_profile_90d_v2`\n)\nSELECT\n  t.username_std,\n  t.scheduler_name,\n  t.date_local,\n  MOD(EXTRACT(DAYOFWEEK FROM t.date_local) + 5, 7) AS dow,  -- 0=Mon..6=Sun\n  q.ppv_quota,\n  q.hour_pool,\n  q.is_burst_dow,\n  w.weight_volume, w.weight_hours, w.weight_price, w.exploration_rate,\n  pp.p35, pp.p50, pp.p60, pp.p80, pp.p90, pp.price_mode, pp.corr_price_rev,\n  d.dow_score,\n  t.slot_rank,\n  t.hod_local,\n  t.price_usd,\n  t.planned_local_datetime,\n  t.scheduled_datetime_utc\nFROM `of-scheduler-proj.mart.weekly_template_7d_latest` t\nLEFT JOIN q  ON q.username_std = t.username_std\n            AND q.dow = MOD(EXTRACT(DAYOFWEEK FROM t.date_local) + 5, 7)\nLEFT JOIN w  ON w.username_std = t.username_std\nLEFT JOIN pp ON pp.username_std = t.username_std\nLEFT JOIN dow d ON d.username_std = t.username_std\n               AND d.dow = MOD(EXTRACT(DAYOFWEEK FROM t.date_local) + 5, 7)\nORDER BY t.username_std, t.date_local, t.slot_rank",
    "schema": [
      {
        "name": "username_std",
        "type": "STRING"
      },
      {
        "name": "scheduler_name",
        "type": "STRING"
      },
      {
        "name": "date_local",
        "type": "DATE"
      },
      {
        "name": "dow",
        "type": "INTEGER"
      },
      {
        "name": "ppv_quota",
        "type": "INTEGER"
      },
      {
        "name": "hour_pool",
        "type": "INTEGER"
      },
      {
        "name": "is_burst_dow",
        "type": "INTEGER"
      },
      {
        "name": "weight_volume",
        "type": "FLOAT"
      },
      {
        "name": "weight_hours",
        "type": "FLOAT"
      },
      {
        "name": "weight_price",
        "type": "FLOAT"
      },
      {
        "name": "exploration_rate",
        "type": "FLOAT"
      },
      {
        "name": "p35",
        "type": "FLOAT"
      },
      {
        "name": "p50",
        "type": "FLOAT"
      },
      {
        "name": "p60",
        "type": "FLOAT"
      },
      {
        "name": "p80",
        "type": "FLOAT"
      },
      {
        "name": "p90",
        "type": "FLOAT"
      },
      {
        "name": "price_mode",
        "type": "STRING"
      },
      {
        "name": "corr_price_rev",
        "type": "FLOAT"
      },
      {
        "name": "dow_score",
        "type": "FLOAT"
      },
      {
        "name": "slot_rank",
        "type": "INTEGER"
      },
      {
        "name": "hod_local",
        "type": "INTEGER"
      },
      {
        "name": "price_usd",
        "type": "FLOAT"
      },
      {
        "name": "planned_local_datetime",
        "type": "DATETIME"
      },
      {
        "name": "scheduled_datetime_utc",
        "type": "TIMESTAMP"
      }
    ]
  }
]
